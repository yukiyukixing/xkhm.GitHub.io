<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>星空海绵 - 星空浩瀚 | 海绵吸水</title>
    <link>https://xkhm.net/</link>
    <description>Recent content on 星空海绵 - 星空浩瀚 | 海绵吸水</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>星空海绵</copyright>
    <lastBuildDate>Mon, 04 Jan 2021 19:44:36 +0800</lastBuildDate>
    
        <atom:link href="https://xkhm.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>细品</title>
      <link>https://xkhm.net/treasury/</link>
      <pubDate>Sat, 02 Jan 2021 19:14:51 +0800</pubDate>
      
      <guid>https://xkhm.net/treasury/</guid>
      
        <description>&lt;h1 id=&#34;程序人生&#34;&gt;程序人生&lt;/h1&gt;
&lt;h2 id=&#34;一个程序员的成长之路---剖析别人总结自己httpsmpweixinqqcomszwpjfhiyxx0hh9le99yijw&#34;&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/zWPjfHiYxx0HH9lE99Yijw&#34;&gt;一个程序员的成长之路 - 剖析别人，总结自己&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;一位前端-2018-绝地求生记--掘金年度征文httpsjuejincnpost6844903758930018311&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844903758930018311&#34;&gt;一位前端 2018 绝地求生记 | 掘金年度征文&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;2019学习学到失恋但是还要继续2019-与我的技术之路httpsjuejincnpost6844904024534155277&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844904024534155277&#34;&gt;2019学习学到失恋但是还要继续|2019 与我的技术之路&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;我看技术人的成长路径httpsjuejincnpost6906006025925558279heading-1&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6906006025925558279#heading-1&#34;&gt;我看技术人的成长路径&lt;/a&gt;&lt;/h2&gt;
&lt;h1 id=&#34;励志鸡汤&#34;&gt;励志鸡汤&lt;/h1&gt;
&lt;h2 id=&#34;一年半女前端的自我救赎-掘金年度征文httpsjuejincnpost6912772782950629389&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6912772782950629389&#34;&gt;一年半女前端的自我救赎 ｜掘金年度征文&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;funnycoder第0期非科班前端老司机从2k到40k之路httpsjuejincnpost6900092004043063309&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6900092004043063309&#34;&gt;【FunnyCoder第0期】非科班前端老司机从2K到40K之路&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;程序员的十年之痒httpsjuejincnpost6892909929066135560&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6892909929066135560&#34;&gt;程序员的十年之痒&lt;/a&gt;&lt;/h2&gt;
&lt;h1 id=&#34;进阶捷径&#34;&gt;进阶捷径&lt;/h1&gt;
&lt;h2 id=&#34;艺术喵-2-年前端面试心路历程字节跳动yy虎牙bigo-掘金技术征文httpsjuejincnpost6844904113302568973heading-2&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844904113302568973#heading-2&#34;&gt;艺术喵 2 年前端面试心路历程（字节跳动、YY、虎牙、BIGO）| 掘金技术征文&lt;/a&gt;&lt;/h2&gt;
&lt;h1 id=&#34;镜子&#34;&gt;镜子&lt;/h1&gt;
&lt;h2 id=&#34;朝花夕拾---寒冬记8月-12月前端的艰苦生存httpsjuejincnpost6900698650616266765heading-0&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6900698650616266765#heading-0&#34;&gt;朝花夕拾 - 寒冬记（8月-12月前端的艰苦生存）&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;我的前端面试心法已拿字节offerhttpsjuejincnpost6898187200035782670heading-0&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6898187200035782670#heading-0&#34;&gt;我的前端面试心法（已拿字节offer）&lt;/a&gt;&lt;/h2&gt;
</description>
      
    </item>
    
    <item>
      <title>提桶</title>
      <link>https://xkhm.net/interview/</link>
      <pubDate>Sat, 02 Jan 2021 19:39:25 +0800</pubDate>
      
      <guid>https://xkhm.net/interview/</guid>
      
        <description>&lt;h1 id=&#34;提桶心得&#34;&gt;提桶心得&lt;/h1&gt;
&lt;h2 id=&#34;我在9家大厂的前端校招offer心得httpsjuejincnpost6844903936189530120&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844903936189530120&#34;&gt;我在9家大厂的前端校招offer心得&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;放手一搏社招java岗面试经历三年经验-pingcap蚂蚁httpsjuejincnpost6844903974823264270heading-0&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844903974823264270#heading-0&#34;&gt;放手一搏：社招Java岗面试经历(三年经验): PingCAP、蚂蚁&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;从青铜到钻石3-年创业公司成长经历--面试总结httpsjuejincnpost6895347434029842440&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6895347434029842440&#34;&gt;【从青铜到钻石】3 年创业公司成长经历 &amp;amp;&amp;amp; 面试总结&lt;/a&gt;&lt;/h2&gt;
&lt;h1 id=&#34;提桶资料&#34;&gt;提桶资料&lt;/h1&gt;
&lt;h2 id=&#34;中高级前端面试javascript手写代码无敌秘籍httpsjuejincnpost6844903809206976520&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844903809206976520&#34;&gt;「中高级前端面试」JavaScript手写代码无敌秘籍&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;一名合格前端工程师的自检清单httpsjuejincnpost6844903830887366670&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844903830887366670&#34;&gt;一名【合格】前端工程师的自检清单&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;前端进阶必备github-优质资源整理分享httpsjuejincnpost6844903902299553806&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844903902299553806&#34;&gt;前端进阶必备，github 优质资源整理分享！&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;jsliang-2020-求职系列httpsjuejincnpost6890075489881948167&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6890075489881948167&#34;&gt;jsliang 2020 求职系列&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;金九银十一年前端的面试分享httpsjuejincnpost6874275613360783368&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6874275613360783368&#34;&gt;金九银十：一年前端的面试分享&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;2020三元同学春招阿里淘系阿里云字节跳动面经--个人成长经验分享--掘金技术征文httpsjuejincnpost6844904106537009159&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844904106537009159&#34;&gt;2020三元同学春招阿里淘系、阿里云、字节跳动面经 &amp;amp; 个人成长经验分享 | 掘金技术征文&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;面试分享两年工作经验成功面试阿里p6总结httpsjuejincnpost6844903928442667015&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844903928442667015&#34;&gt;面试分享：两年工作经验成功面试阿里P6总结&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;2万字--前端基础拾遗90问httpsjuejincnpost6844904116552990727&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844904116552990727&#34;&gt;2万字 | 前端基础拾遗90问&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;面试题20vue面试题整理httpsjuejincnpost6844904084374290446&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844904084374290446&#34;&gt;「面试题」20+Vue面试题整理&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;一位前端小姐姐的五万字面试宝典httpsjuejincnpost6844904121380667399&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844904121380667399&#34;&gt;一位前端小姐姐的五万字面试宝典&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;10-个-github-上超火的前端面试项目打造自己的加薪宝库httpsjuejincnpost6895752757534261256&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6895752757534261256&#34;&gt;10 个 GitHub 上超火的前端面试项目，打造自己的加薪宝库！&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;2020年前端面试复习必读文章超三百篇文章赠复习导图httpsjuejincnpost6844904116339261447&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844904116339261447&#34;&gt;2020年前端面试复习必读文章【超三百篇文章/赠复习导图】&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;106-道面向初中级前端的基础面试题httpsjuejincnpost6898121476864638989&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6898121476864638989&#34;&gt;106 道面向初中级前端的基础面试题&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;查漏补缺那些漏掉的面试知识httpsjuejincnpost6900005459856457735&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6900005459856457735&#34;&gt;【查漏补缺】那些漏掉的面试知识&lt;/a&gt;&lt;/h2&gt;
</description>
      
    </item>
    
    <item>
      <title>生活</title>
      <link>https://xkhm.net/life/</link>
      <pubDate>Sat, 19 Dec 2020 22:14:17 +0800</pubDate>
      
      <guid>https://xkhm.net/life/</guid>
      
        <description>&lt;h1 id=&#34;页面结构待完善&#34;&gt;页面结构待完善&lt;/h1&gt;
&lt;p&gt;待完善&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>技术</title>
      <link>https://xkhm.net/technology/</link>
      <pubDate>Sat, 19 Dec 2020 22:19:35 +0800</pubDate>
      
      <guid>https://xkhm.net/technology/</guid>
      
        <description>&lt;h1 id=&#34;页面结构待完善&#34;&gt;页面结构待完善&lt;/h1&gt;
&lt;p&gt;待完善&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>随笔</title>
      <link>https://xkhm.net/essay/</link>
      <pubDate>Sat, 19 Dec 2020 22:17:09 +0800</pubDate>
      
      <guid>https://xkhm.net/essay/</guid>
      
        <description>&lt;h1 id=&#34;页面结构待完善&#34;&gt;页面结构待完善&lt;/h1&gt;
&lt;p&gt;待完善&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>待做</title>
      <link>https://xkhm.net/tobedone/</link>
      <pubDate>Sat, 19 Dec 2020 22:19:35 +0800</pubDate>
      
      <guid>https://xkhm.net/tobedone/</guid>
      
        <description>&lt;h1 id=&#34;页面结构待完善&#34;&gt;页面结构待完善&lt;/h1&gt;
&lt;p&gt;待完善&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>关于</title>
      <link>https://xkhm.net/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://xkhm.net/about/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;一只小透明的前端开发（待补充）&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>Vue2从入门到CV</title>
      <link>https://xkhm.net/post/vue2%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0cv/</link>
      <pubDate>Mon, 04 Jan 2021 19:44:36 +0800</pubDate>
      
      <guid>https://xkhm.net/post/vue2%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0cv/</guid>
      
        <description>&lt;h1 id=&#34;1vue是什么&#34;&gt;1.Vue是什么？&lt;/h1&gt;
&lt;p&gt;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的&lt;strong&gt;渐进式框架&lt;/strong&gt;。与其它大型框架不同的是，Vue 被设计为可以&lt;strong&gt;自底向上逐层应用&lt;/strong&gt;。&lt;strong&gt;Vue 的核心库只关注视图层&lt;/strong&gt;，不仅易于上手，还&lt;strong&gt;便于与第三方库或既有项目整合&lt;/strong&gt;。另一方面，当与&lt;strong&gt;现代化的工具链以及各种支持类库结合使用&lt;/strong&gt;时，Vue 也完全能够为复杂的单页应用提供驱动。&lt;/p&gt;
&lt;p&gt;Vue.js 的核心是一个允许采用简洁的模板语法来声明式地&lt;strong&gt;将数据渲染进 DOM 的系统&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;2特点&#34;&gt;2.特点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;1.html内容可以是变量 {{}}&lt;/li&gt;
&lt;li&gt;2.属性内容也可以是变量 v-bind 缩写： :&lt;/li&gt;
&lt;li&gt;3.可以通过指令控制显示隐藏 v-if&lt;/li&gt;
&lt;li&gt;4.绑定数组元素来渲染列表 v-for&lt;/li&gt;
&lt;li&gt;5.给dom绑定方法v-on 缩写 @  数据驱动视图改变&lt;/li&gt;
&lt;li&gt;6.表单状态和应用状态之间双向绑定 v-model&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3组件化构建应用&#34;&gt;3.组件化构建应用&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;组件系统是 Vue 的另一个重要概念&lt;/strong&gt;，因为它是一种抽象，&lt;strong&gt;允许我们使用小型、独立和通常可复用的组件构建大型应用&lt;/strong&gt;。仔细想想，几乎任意类型的应用界面都可以抽象为一个&lt;strong&gt;组件树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;组件使用：&lt;/p&gt;
&lt;p&gt;1.注册 Vue.component()&lt;/p&gt;
&lt;p&gt;组件数据传输：&lt;/p&gt;
&lt;p&gt;1.父组件将数据传输给子组件 props&lt;/p&gt;
&lt;p&gt;2.props相当于在模板（子组件）上挂了一个可以进行数据绑定的属性（个人理解）&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;viewport&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;Document&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;app-2&amp;#34;&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;ol&lt;/span&gt;&amp;gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 创建一个 todo-item 组件的实例 --&amp;gt;&lt;/span&gt;
            &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;todo-item&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v-for&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;item in groceryList&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;:todo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;item&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;:key&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;item.id&amp;#34;&lt;/span&gt;&amp;gt;

            &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;todo-item&lt;/span&gt;&amp;gt;
        &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;ol&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./vue.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
        &lt;span style=&#34;color:#a6e22e&#34;&gt;Vue&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;component&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;todo-item&amp;#39;&lt;/span&gt;, {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;props&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;todo&amp;#39;&lt;/span&gt;],
            &lt;span style=&#34;color:#a6e22e&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;lt;li&amp;gt;{{ todo.text }}&amp;lt;/li&amp;gt;&amp;#39;&lt;/span&gt;
        })
        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;app2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Vue&lt;/span&gt;({
            &lt;span style=&#34;color:#a6e22e&#34;&gt;el&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#app-2&amp;#39;&lt;/span&gt;,
            &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;groceryList&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; [
                    { &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;text&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;西红柿&amp;#39;&lt;/span&gt; },
                    { &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;text&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;茄子&amp;#39;&lt;/span&gt; },
                    { &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;text&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;西瓜&amp;#39;&lt;/span&gt; }
                ]
            }
        })
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;个人理解：这个例子就相当于props属性值todo挂在template上作为一个可以进行数据绑定的属性，绑定的数据在template定义的html内容中可以使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;4vue组件化与自定义元素的关系&#34;&gt;4.Vue组件化与自定义元素的关系&lt;/h1&gt;
&lt;p&gt;组件思想参考自定义元素Web组件规范，但是与自定义元素还是有区别：&lt;/p&gt;
&lt;p&gt;1.Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，&lt;strong&gt;Vue 组件也可以包装于原生自定义元素之内。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.Vue 组件提供了纯自定义元素所不具备的一些重要功能，&lt;strong&gt;最突出的是跨组件数据流、自定义事件通信以及构建工具集成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，&lt;strong&gt;依然有很好的互操作性。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;5vue实例&#34;&gt;5.Vue实例&lt;/h1&gt;
&lt;h2 id=&#34;1vue实例介绍&#34;&gt;（1）Vue实例介绍&lt;/h2&gt;
&lt;p&gt;每个 &lt;strong&gt;Vue 应用&lt;/strong&gt; 都是通过用 &lt;strong&gt;Vue 函数&lt;/strong&gt; 创建一个新的 &lt;strong&gt;Vue 实例&lt;/strong&gt; 开始的。一个 &lt;strong&gt;Vue 应用&lt;/strong&gt; 由一个通过 &lt;strong&gt;new Vue&lt;/strong&gt; 创建的根 &lt;strong&gt;Vue 实例&lt;/strong&gt;，以及可选的嵌套的、可复用的&lt;strong&gt;组件树&lt;/strong&gt;组成。&lt;/p&gt;
&lt;p&gt;虽然没有完全遵循 &lt;strong&gt;MVVM 模型&lt;/strong&gt;，但是 &lt;strong&gt;Vue 的设计&lt;/strong&gt;也受到了它的启发。因此在文档中经常会使用 &lt;strong&gt;vm (ViewModel 的缩写)&lt;/strong&gt; 这个变量名表示 &lt;strong&gt;Vue 实例&lt;/strong&gt;。当创建一个 &lt;strong&gt;Vue 实例&lt;/strong&gt; 时，你可以传入一个&lt;strong&gt;选项对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;2vue实例数据挂载&#34;&gt;（2）Vue实例数据挂载&lt;/h2&gt;
&lt;p&gt;当一个 &lt;strong&gt;Vue 实例&lt;/strong&gt;被创建时，它将 &lt;strong&gt;data 对象&lt;/strong&gt; 中的所有的 &lt;strong&gt;property&lt;/strong&gt; 加入到 &lt;strong&gt;Vue 的响应式系统&lt;/strong&gt;中。当这些 &lt;strong&gt;property&lt;/strong&gt; 的值发生改变时，&lt;strong&gt;视图将会产生“响应”&lt;/strong&gt;，即匹配更新为新的值。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JavaScript&#34; data-lang=&#34;JavaScript&#34;&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 我们的数据对象
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; }

  &lt;span style=&#34;color:#75715e&#34;&gt;// 该对象被加入到一个 Vue 实例中
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Vue&lt;/span&gt;({
    &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;
  })

  &lt;span style=&#34;color:#75715e&#34;&gt;// 获得这个实例上的 property
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 返回源数据中对应的字段
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// =&amp;gt; true
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;// 设置 property 也会影响到原始数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
  &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// =&amp;gt; 2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;// ……反之亦然
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
  &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// =&amp;gt; 3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们是不是可以猜测一下Vue内部是按照下面这样处理的呢：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;viewport&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;Document&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;({
            &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;
        })
        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt;);
        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;);
        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;);
        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;);
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;

&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。也就是说如果你添加一个新的 property，将不会触发任何视图的更新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来,这些方法可以用来操作实例的属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;3生命周期&#34;&gt;（3）生命周期&lt;/h2&gt;
&lt;p&gt;每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置 &lt;strong&gt;数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM&lt;/strong&gt; 等。同时在这个过程中也会运行一些叫做&lt;strong&gt;生命周期钩子的函数&lt;/strong&gt;，这给了用户在不同阶段添加自己的代码的机会。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/834579665f494f66a1da0cf45c0635c7~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;6vue模板语法&#34;&gt;6.Vue模板语法&lt;/h1&gt;
&lt;p&gt;Vue.js 使用了基于 HTML 的模板语法，允许开发者&lt;strong&gt;声明式地将 DOM 绑定至底层 Vue 实例&lt;/strong&gt;的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。&lt;/p&gt;
&lt;p&gt;在底层的实现上，&lt;strong&gt;Vue 将模板编译成虚拟 DOM 渲染函数&lt;/strong&gt;。结合响应系统，&lt;strong&gt;Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你熟悉 &lt;strong&gt;虚拟 DOM&lt;/strong&gt; 并且&lt;strong&gt;偏爱 JavaScript 的原始力量&lt;/strong&gt;，你也可以不用模板，直接写&lt;strong&gt;渲染 (render) 函数，使用可选的 JSX 语法。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-mustache语法-双大括号&#34;&gt;（1） “Mustache”语法 (双大括号)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&amp;lt;span&amp;gt;Message: {{ msg }}&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Mustache 标签将会被替代为对应数据对象上 msg property 的值。无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。&lt;/p&gt;
&lt;p&gt;通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&amp;lt;span v-once&amp;gt;这个将不会改变: {{ msg }}&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：可以用 v-once 优化更新性能 -&amp;gt; 重要&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2原始-html&#34;&gt;（2）原始 HTML&lt;/h1&gt;
&lt;p&gt;双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;  &amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot; v-once&amp;gt;
      &amp;lt;p&amp;gt;{{ text }}&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;&amp;lt;span v-html=&amp;quot;text&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;script src=&amp;quot;./vue.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;

      let app = new Vue({
          el: &#39;#app&#39;,
          data: {
              text: &#39;Hello&amp;lt;i&amp;gt;你好&amp;lt;/i&amp;gt;&#39;
          }
      })
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e991c97e6c4a4f4c90adce232c6a337e~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上面这个例子可以看出双大括号并不能渲染标签内容&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：这个 span 的内容将会被替换成为 property 值 rawHtml，直接作为 HTML——会忽略解析 property 值中的数据绑定。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;重要：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3attribute属性绑定&#34;&gt;（3）Attribute属性绑定&lt;/h2&gt;
&lt;p&gt;Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 v-bind 指令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&amp;lt;div v-bind:id=&amp;quot;dynamicId&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果 attribute 值为null，undefined，false，attribute不会包含在被渲染的dom中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;绑定样式的时候注意，Vue有单独绑定style和class的规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4使用-javascript-表达式&#34;&gt;（4）使用 JavaScript 表达式&lt;/h2&gt;
&lt;p&gt;这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&amp;lt;!-- 这是语句，不是表达式 --&amp;gt;
{{ var a = 1 }}

&amp;lt;!-- 流控制也不会生效，请使用三元表达式 --&amp;gt;
{{ if (ok) { return message } }}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5指令&#34;&gt;（5）指令&lt;/h2&gt;
&lt;p&gt;指令 (Directives) 是带有 v- 前缀的特殊 &lt;strong&gt;attribute&lt;/strong&gt;。指令 attribute 的值预期是单个 &lt;strong&gt;JavaScript 表达式&lt;/strong&gt; (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&amp;lt;p v-if=&amp;quot;seen&amp;quot;&amp;gt;现在你看到我了&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;6参数&#34;&gt;（6）参数&lt;/h2&gt;
&lt;p&gt;一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML attribute：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v-bind:href&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;&amp;gt;...&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一个例子是 v-on 指令，它用于监听 DOM 事件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v-on:click&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;doSomething&amp;#34;&lt;/span&gt;&amp;gt;...&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里参数是监听的事件名。我们也会更详细地讨论事件处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：这里提到的v-bind和v-on语法，后面跟的属性是传给它们的参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;7动态参数&#34;&gt;（7）动态参数&lt;/h2&gt;
&lt;p&gt;从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v-bind:&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;attributeName&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;]=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#34;&lt;/span&gt;&amp;gt; ... &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v-on:&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;eventName&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;]=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;doSomething&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#34;&lt;/span&gt;&amp;gt; ... &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;对动态参数的值的约束：动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;对动态参数表达式的约束:动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 这会触发一个编译警告 --&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v-bind:&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;[&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;]=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#34;&lt;/span&gt;&amp;gt; ... &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;除非在实例中有一个名为“someattr”的 property，否则代码不会工作。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v-bind:&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;someAttr&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;]=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#34;&lt;/span&gt;&amp;gt; ... &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;个人理解：动态参数使用得得当的话在写业务的时候作用应该非常大&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;8修饰符&#34;&gt;（8）修饰符&lt;/h2&gt;
&lt;p&gt;修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;form&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v-on:submit&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;prevent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;onSubmit&amp;#34;&lt;/span&gt;&amp;gt;...&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;form&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在接下来对 v-on 和 v-for 等功能的探索中，你会看到修饰符的其它例子。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;inspiration：程序员还是需要会“偷懒”的，能少些一个字符就少写一个字符，程序简洁也很重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;9缩写&#34;&gt;（9）缩写&lt;/h2&gt;
&lt;p&gt;v-bind 缩写： :&lt;/p&gt;
&lt;p&gt;v-on 缩写： @&lt;/p&gt;
&lt;h1 id=&#34;7计算器和侦听属性&#34;&gt;7.计算器和侦听属性&lt;/h1&gt;
&lt;h2 id=&#34;1计算属性&#34;&gt;（1）计算属性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;什么样的表达式写到Mustache语法中，什么样的表达式需要用到计算属性，注意区分使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;example&amp;#34;&lt;/span&gt;&amp;gt;
  {{ message.split(&amp;#39;&amp;#39;).reverse().join(&amp;#39;&amp;#39;) }}
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以，&lt;strong&gt;对于任何复杂逻辑，你都应当使用计算属性。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;viewport&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;Document&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;example&amp;#34;&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;Original message: &amp;#34;{{ message }}&amp;#34;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;Computed reversed message: &amp;#34;{{ reversedMessage }}&amp;#34;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./vue.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Vue&lt;/span&gt;({
            &lt;span style=&#34;color:#a6e22e&#34;&gt;el&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#example&amp;#39;&lt;/span&gt;,
            &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Hello&amp;#39;&lt;/span&gt;
            },
            &lt;span style=&#34;color:#a6e22e&#34;&gt;computed&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 计算属性的 getter
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;reversedMessage&lt;/span&gt;() {
                    &lt;span style=&#34;color:#75715e&#34;&gt;// `this` 指向 vm 实例
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;split&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;reverse&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;join&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;)
                }
            }
        })
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;

&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。计算属性也是双向绑定。&lt;/p&gt;
&lt;h2 id=&#34;2计算属性缓存-vs-方法&#34;&gt;（2）计算属性缓存 vs 方法&lt;/h2&gt;
&lt;p&gt;我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，&lt;strong&gt;不同的是计算属性是基于它们的响应式依赖进行缓存的。&lt;/strong&gt; 只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&amp;lt;p&amp;gt;Reversed message: &amp;quot;{{ reversedMessage() }}&amp;quot;&amp;lt;/p&amp;gt;
// 在组件中
methods: {
  reversedMessage: function () {
    return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;个人理解：使用component计算属性会有缓存，不会每次去调用函数，而使用methods会每次去调用函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;viewport&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;Document&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;example&amp;#34;&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;Original message: &amp;#34;{{ message }}&amp;#34;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;Computed reversed message: &amp;#34;{{ reversedMessage }}&amp;#34;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;Computed reversed message: &amp;#34;{{ reversedMessage }}&amp;#34;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;Computed reversed message: &amp;#34;{{ reversedMessage }}&amp;#34;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./vue.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Vue&lt;/span&gt;({
            &lt;span style=&#34;color:#a6e22e&#34;&gt;el&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#example&amp;#39;&lt;/span&gt;,
            &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Hello&amp;#39;&lt;/span&gt;
            },
            &lt;span style=&#34;color:#a6e22e&#34;&gt;computed&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;reversedMessage&lt;/span&gt;() {
                    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;computed&amp;#39;&lt;/span&gt;);
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;split&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;reverse&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;join&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;)
                }
            }
        })
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;

&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码只会打印一次computed。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;viewport&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;Document&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;example&amp;#34;&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;Original message: &amp;#34;{{ message }}&amp;#34;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;Computed reversed message: &amp;#34;{{ reversedMessage() }}&amp;#34;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;Computed reversed message: &amp;#34;{{ reversedMessage() }}&amp;#34;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;Computed reversed message: &amp;#34;{{ reversedMessage() }}&amp;#34;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;p&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./vue.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Vue&lt;/span&gt;({
            &lt;span style=&#34;color:#a6e22e&#34;&gt;el&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#example&amp;#39;&lt;/span&gt;,
            &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Hello&amp;#39;&lt;/span&gt;
            },
            &lt;span style=&#34;color:#a6e22e&#34;&gt;methods&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;reversedMessage&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
                    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;methods&amp;#39;&lt;/span&gt;);
                    &lt;span style=&#34;color:#75715e&#34;&gt;// `this` 指向 vm 实例
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;message&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;split&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;reverse&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;join&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;)
                }
            }
        })
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;

&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这段代码会打印三次 methods&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;3计算属性-vs-侦听属性&#34;&gt;（3）计算属性 vs 侦听属性&lt;/h2&gt;
&lt;p&gt;Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;viewport&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;Document&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;demo&amp;#34;&lt;/span&gt;&amp;gt;{{ fullName }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./vue.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Vue&lt;/span&gt;({
            &lt;span style=&#34;color:#a6e22e&#34;&gt;el&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#demo&amp;#39;&lt;/span&gt;,
            &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;firstName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Foo&amp;#39;&lt;/span&gt;,
                &lt;span style=&#34;color:#a6e22e&#34;&gt;lastName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Bar&amp;#39;&lt;/span&gt;
            },
            &lt;span style=&#34;color:#a6e22e&#34;&gt;computed&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;fullName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;firstName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lastName&lt;/span&gt;
                }
            }
        })
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;

&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;viewport&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;Document&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;demo&amp;#34;&lt;/span&gt;&amp;gt;{{ fullName }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./vue.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vm&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Vue&lt;/span&gt;({
            &lt;span style=&#34;color:#a6e22e&#34;&gt;el&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#demo&amp;#39;&lt;/span&gt;,
            &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;firstName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Foo&amp;#39;&lt;/span&gt;,
                &lt;span style=&#34;color:#a6e22e&#34;&gt;lastName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Bar&amp;#39;&lt;/span&gt;,
                &lt;span style=&#34;color:#a6e22e&#34;&gt;fullName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Foo Bar&amp;#39;&lt;/span&gt;
            },
            &lt;span style=&#34;color:#a6e22e&#34;&gt;watch&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;firstName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt;) {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;fullName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lastName&lt;/span&gt;
                },
                &lt;span style=&#34;color:#a6e22e&#34;&gt;lastName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt;) {
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;fullName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;firstName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt;
                }
            }
        })
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;

&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;在这个例子中，上面的computed写法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：什么时候使用computed，什么时候使用watch，需要知道区别。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>JS面试题复习</title>
      <link>https://xkhm.net/post/js%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Mon, 04 Jan 2021 08:30:30 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%8D%E4%B9%A0/</guid>
      
        <description>&lt;h1 id=&#34;1对象&#34;&gt;1.对象&lt;/h1&gt;
&lt;h2 id=&#34;1深浅拷贝&#34;&gt;（1）深浅拷贝&lt;/h2&gt;
&lt;p&gt;1.浅拷贝（4种）&lt;/p&gt;
&lt;p&gt;（1）直接赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;XKHM&#39;,
            age: 25,
            job: &#39;Software Engineer&#39;
        }
        let obj1 = obj;
        console.log(obj1 === obj);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（2）Object.assign()&lt;/p&gt;
&lt;p&gt;Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。&lt;strong&gt;它将返回目标对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;Object.assign(target, &amp;hellip;sources)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：第一个参数之后可以跟多个对象参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;XKHM&#39;,
            age: 25,
            job: &#39;Software Engineer&#39;
        }
        let obj3 = {
            money: 50
        }
        let obj1 = {};
        Object.assign(obj1, obj, obj3)
        console.log(obj1);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;利用Object.assign()进行浅拷贝：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;XKHM&#39;,
            age: 25,
            job: &#39;Software Engineer&#39;
        }
        let obj1 = Object.assign({}, obj);
        obj1.age = 28;
        console.log(obj1);
        console.log(obj);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（3）使用展开语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;XKHM&#39;,
            age: 25,
            job: &#39;Software Engineer&#39;
        }
        let obj1 = { ...obj };
        obj1.age = 28;
        console.log(obj1);
        console.log(obj);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（4）循环遍历赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;XKHM&#39;,
            age: 25,
            job: &#39;Software Engineer&#39;
        }
        let obj1 = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                obj1[key] = obj[key];
            }
        }
        obj1.age = 28;
        console.log(obj1);
        console.log(obj);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;拓展：遍历对象的几种方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.for&amp;hellip;in 会遍历继承到的属性，注意判断&lt;/li&gt;
&lt;li&gt;2.Object.keys(obj)，Object.values(obj)，Object.entries(obj)&lt;/li&gt;
&lt;li&gt;3.Object.getOwnPropertyNames()&lt;/li&gt;
&lt;li&gt;4.Reflect.ownKeys&lt;/li&gt;
&lt;li&gt;5.借用展开语法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.深拷贝&lt;/p&gt;
&lt;p&gt;（1）JSON.parse(JSON.stringify())&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: {
                firstName: &#39;星空&#39;,
                lastName: &#39;海绵&#39;
            },
            age: 25,
            job: &#39;Software Engineer&#39;
        }
        let obj1 = JSON.parse(JSON.stringify(obj));
        obj1.name.firstName = &#39;小小&#39;
        console.log(obj1);
        console.log(obj);
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;缺陷：这个方法不能处理function和undefined、Symbol，会直接忽略&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>时间管理和效率</title>
      <link>https://xkhm.net/post/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%92%8C%E6%95%88%E7%8E%87/</link>
      <pubDate>Sun, 03 Jan 2021 13:54:24 +0800</pubDate>
      
      <guid>https://xkhm.net/post/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%92%8C%E6%95%88%E7%8E%87/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;前言，一般情况下，当一个人想更优秀时，他就会去学习怎样在有限的时间里可以处理更多的事情，这就涉及到了时间管理和效率的问题，我最近也一直在思考，我的时间管理是否正确，我的干活效率该如何提高，因为我最近急于提高自己的专业水平，我已经开始占用我的睡觉时间了，但是如果我某天睡眠不足的话，下午或者晚上必然会头疼，当然这是正常现象，因为睡眠不足导致大脑供氧不足，所以头疼，这也让我明白睡觉时间时不能占用的，因为一旦开始头疼就不能专心干活了，会损失掉更多的时间，所以我急需一套时间管理以及提高效率的方案。于是我就去Google知乎搜索相关问题，以寻求到一个接近正确的答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1时间思考&#34;&gt;1.时间思考&lt;/h1&gt;
&lt;h2 id=&#34;时间分类&#34;&gt;时间分类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/721405754abb4eb1bd3447436e556b1c~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;观点1时间弹性很大&#34;&gt;观点1：时间弹性很大&lt;/h2&gt;
&lt;p&gt;有一个例子，时一个女士家中热水器坏了，地下室被淹了，然后她找来工人修理热水器和处理地毯，在一周里花费了7小时。我们换一个思路想一下，如果热水器没坏，这个女士的这7个小时会干嘛呢，所以说重要的事情需要花时间优先处理。&lt;/p&gt;
&lt;h2 id=&#34;观点2时间--选择&#34;&gt;观点2：时间 = 选择&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;没时间做就意味着这件事情并不重要，所以日常就需要思考，哪些事情时重要的，是值得花时间去做的。&lt;/strong&gt; 对以后有帮助的，可以获得长期收益的。当年终的时候你在回顾你整年的时候，希望有价值的事情充满着你整年的时间。对待重要的事情，就要像对待坏掉的热水器，把他们放到日程表的第一栏。制定计划，量化时间，一周 24×7=168H ，除去每天7.5小时的睡觉时间，每周会剩下 168-7.5×7 = 115.5H，然后再去除正常的工作时间，115.5-10.5×5=64H，也就是说一周除去睡觉和工作，有64个小时的时间可以利用。&lt;/p&gt;
&lt;h2 id=&#34;观点3大脑切换有启动成本&#34;&gt;观点3：大脑切换有启动成本&lt;/h2&gt;
&lt;p&gt;那么这个观点是否意味着番茄学习法不正确呢？个人觉得这个观点有一定的道理，但是番茄学习法也是有道理的，举两个例子，比如说手机，你开机是需要时间的，现在这个手机就相当于大脑，这就是大脑切换有启动成本，再就是你使用手机使用到0%再充电跟使用到60%再充电，哪个使用效率会更高，这里就涉及到效率的问题了，是长时间专注效率高，还是使用番茄学习法效率高呢，值得思考。&lt;/p&gt;
&lt;h2 id=&#34;观点4提高做事效率提高时间利用率&#34;&gt;观点4：提高做事效率，提高时间利用率&lt;/h2&gt;
&lt;p&gt;这个观点也就是在有限的时间里做更多的事情，这样我们就能拥有更多的时间。&lt;/p&gt;
&lt;h2 id=&#34;观点5帕金森定律&#34;&gt;观点5：帕金森定律&lt;/h2&gt;
&lt;p&gt;任务完成的时间取决于你分配给它的时间&lt;/p&gt;
&lt;h2 id=&#34;观点6崔西定律&#34;&gt;观点6：崔西定律&lt;/h2&gt;
&lt;p&gt;简化有些事情的流程，去除不必要的步骤。但是前提是得明白做着件事情的意义，比如学习，是学会，不是学完。尽可能的简化做一件事情的步骤，这回大大节省时间。&lt;/p&gt;
&lt;h2 id=&#34;观点7两分钟法则&#34;&gt;观点7：两分钟法则&lt;/h2&gt;
&lt;p&gt;如果你有一个完成时间低于两分钟的任务，那么你应该马上完成，而不是把他推迟。这一点的话需不需要考虑到事情的重要性呢，有待考究。&lt;/p&gt;
&lt;h2 id=&#34;观点8批处理法则&#34;&gt;观点8：批处理法则&lt;/h2&gt;
&lt;p&gt;不要在多任务之间转换，每周拿出固定时间一次性处理完一种任务。&lt;/p&gt;
&lt;h1 id=&#34;2提高效率&#34;&gt;2.提高效率&lt;/h1&gt;
&lt;h2 id=&#34;1严格执行计划&#34;&gt;（1）严格执行计划&lt;/h2&gt;
&lt;p&gt;在规定的时间内完成制定的计划，不要拖延，前提是制定的计划需要合理&lt;/p&gt;
&lt;h2 id=&#34;2识别每项任务的关键点注意&#34;&gt;（2）识别每项任务的关键点（注意）&lt;/h2&gt;
&lt;p&gt;不要死磕有些细节，其实那些细节真的没有那么重要，反而浪费的大量的时间，让你没有时间做最重要的部分，要明白任务的关键点，哪些细节可以忽略掉，我觉得我需要做到这一点，因为我学习一个只是点的时候，我就会想到把这个知识点涉及到的所有知识点都吃透，显然这回花费掉很多的时间，这也就导致计划不能在该完成的时间里完成。接受有些事情的不完美，但是不是所有事情都不完美就行了，有些事情还是需要有强迫症的，必须完美。&lt;/p&gt;
&lt;h2 id=&#34;3保持专注&#34;&gt;（3）保持专注&lt;/h2&gt;
&lt;p&gt;整块的时间里，专注于一件事情，比如一次专注1个小时，一直干一件事情不被外界所打扰，因为大脑启动是需要浪费时间的，而大脑专注也是有时间限制的，不可能说一次专注一天吧，结合番茄学习法，适当的进行休息。&lt;/p&gt;
&lt;h2 id=&#34;4顺应自己的生物钟&#34;&gt;（4）顺应自己的生物钟&lt;/h2&gt;
&lt;p&gt;人的大脑在一天中的3个时间段比较活跃：&lt;/p&gt;
&lt;p&gt;早起后的 3~4 个小时，中午过后 3~4 个小时，晚上 7~9 点&lt;/p&gt;
&lt;p&gt;我觉得我早上和晚上干活的效率比较高，大脑灵活，特别是早上，睡醒了，刚起来大脑没有疲惫感，想问题快。所以比较重要的事情需要放在这些时间段。&lt;/p&gt;
&lt;h2 id=&#34;5可视化时间管理&#34;&gt;（5）可视化时间管理&lt;/h2&gt;
&lt;p&gt;结合手机上的App进行可视化的时间管理&lt;/p&gt;
&lt;h2 id=&#34;6每天复盘自己的时间&#34;&gt;（6）每天复盘自己的时间&lt;/h2&gt;
&lt;h2 id=&#34;7明白某一段时间里最重要的事情&#34;&gt;（7）明白某一段时间里最重要的事情&lt;/h2&gt;
&lt;h1 id=&#34;结论&#34;&gt;结论&lt;/h1&gt;
&lt;p&gt;1.理清事情的优先级，重要的事情放前面&lt;/p&gt;
&lt;p&gt;2.量化可视化时间&lt;/p&gt;
&lt;p&gt;3.完成任务的时间取决于你分配给它的时间&lt;/p&gt;
&lt;p&gt;4.崔西定律，简化任务流程&lt;/p&gt;
&lt;p&gt;5.制定合理的计划，配合手机app完成计划，重要的放前面&lt;/p&gt;
&lt;p&gt;6.识别每项任务的关键点&lt;/p&gt;
&lt;p&gt;7.保持专注,在自己高效的时间里做最重要的事情&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重点：事情优先级，每段时间有事情核心，量化时间，制定合理计划，识别任务关键点，简化任务流程，保持专注高效&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>JS之日常解题</title>
      <link>https://xkhm.net/post/js%E4%B9%8B%E6%97%A5%E5%B8%B8%E8%A7%A3%E9%A2%98/</link>
      <pubDate>Thu, 31 Dec 2020 22:06:11 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E4%B9%8B%E6%97%A5%E5%B8%B8%E8%A7%A3%E9%A2%98/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;前言：好记性不如烂笔头，知识来自于点点滴滴的记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1取出对象中一部分放到另一个对象中&#34;&gt;1.取出对象中一部分放到另一个对象中&lt;/h2&gt;
&lt;p&gt;今天下午在掘金摸鱼的时候，看见有一个小同学发了一个&lt;a href=&#34;https://juejin.cn/pin/6912343800257970184&#34;&gt;沸点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca3d8e11e36b45108118e39c3a5cd780~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;嗯嗯 ，日常要我写的话，以前可能我也会这么写，但是经过我最近一段时间的学习，我可能会用&lt;strong&gt;解构赋值&lt;/strong&gt;来写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        const objOne = {
            name: &#39;xiaoMing&#39;,
            age: 18,
            id: 1234,
            gender: 1
        }
        const { name, id } = objOne;
        const objTwo = { name, id };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我可能会像上面这样写，这些些真的很优雅吗，我觉得跟上面那位小同学写的也没什么区别，还多一行代码，并不是一个好的方案，像我这么机灵的&lt;strong&gt;搜索引擎&lt;/strong&gt;工程师，那么我就开始&lt;strong&gt;Google&lt;/strong&gt;一下，于是找到一个&lt;a href=&#34;https://segmentfault.com/q/1010000012715651&#34;&gt;讨论贴&lt;/a&gt;，针不戳，里面果然有几种比较秒的写法，显得有点高端。&lt;/p&gt;
&lt;h2 id=&#34;1第一种&#34;&gt;（1）第一种&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        const objOne = {
            name: &#39;xiaoMing&#39;,
            age: 18,
            id: 1234,
            gender: 1
        }
        const { age, gender, ...objTwo } = objOne;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种也是利用的对象解构，把剩余的值赋给了objTwo，但是如果我原对象中有30个属性，我只需要取两个呢，那我岂不是得写很多。&lt;/p&gt;
&lt;h2 id=&#34;2第二种&#34;&gt;（2）第二种&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        const objOne = {
            name: &#39;xiaoMing&#39;,
            age: 18,
            id: 1234,
            gender: 1
        }
        const objTwo = (({ name, id }) =&amp;gt; ({ name, id }))(objOne)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这种也是解构，不过这里用了一个立即执行函数，还是比较秒的，但是本质上还是解构的思想，跟上面的有同样的问题，假如我要取28个属性呢，那岂不是要写很多。&lt;/p&gt;
&lt;h2 id=&#34;3第三种&#34;&gt;（3）第三种&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        const objOne = {
            name: &#39;xiaoMing&#39;,
            age: 18,
            id: 1234,
            gender: 1
        }
        const pick = (obj, arr) =&amp;gt; arr.reduce((iter, val) =&amp;gt;
            (val in obj &amp;amp;&amp;amp; (iter[val] = obj[val]), iter), {});

        const objTwo = pick(objOne, [&#39;name&#39;, &#39;id&#39;]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种刚看是不是还有点不明白，首先箭头函数箭头后面不写大括号{}的时候，会自动return，这是箭头函数带的特性，再就是 &lt;strong&gt;(val in obj &amp;amp;&amp;amp; (iter[val] = obj[val]), iter)&lt;/strong&gt; 这一句代码是不是看着有点不是很懂，前面倒是知道，就是判断，那这个逗号是什么意思呢，其实我刚看也没看懂，就直接翻了一下 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comma_Operator&#34;&gt;逗号操作符&amp;ndash;MDN&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MDN 前端滴神 yyds&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;逗号操作符  对它的每个操作数求值（从左到右），并返回最后一个操作数的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说上面这一行代码会返回每次的操作结果，然后用这个操作结果再进行下一次操作，上面的代码也就相当于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        const objOne = {
            name: &#39;xiaoMing&#39;,
            age: 18,
            id: 1234,
            gender: 1
        }
        const pick = (obj, arr) =&amp;gt; arr.reduce((iter, val) =&amp;gt; {
            if (val in obj &amp;amp;&amp;amp; (iter[val] = obj[val])) {
                return iter
            }
        }, {});
        const objTwo = pick(objOne, [&#39;name&#39;, &#39;id&#39;]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是上面用逗号写的确实会更简洁，对不懂逗号操作符的人来说可能不是很明了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面这三种写法相对而言比之前看着高大上一点，只是CodeReview的时候看着没那么呆🤗🤗，显得拉风一点，照日常来说，写出解构就行了，但是你要是会什么奇技淫巧也可以写出来，CodeReview同事看着这代码如果他不懂的话直呼大神，要是看懂了可能会发出一声惊叹，秒啊，也有可能是，就这？，花里胡哨，不如最开始的直接取过来赋值，简洁明了，立马看懂😏😏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2判断一个变量同时等于多个数值&#34;&gt;2.判断一个变量同时等于多个数值&lt;/h1&gt;
&lt;p&gt;这是今天看B站上的一个&lt;a href=&#34;https://www.bilibili.com/video/BV1aV41187cU&#34;&gt;UP&lt;/a&gt;的视频里面，UP提出来的，当然之前我也看到过，只是没有仔细的研究，只是今天看视频又看见了，想着连着上面那一题一起记录一下吧，毕竟好记性不如烂笔头嘛🤔🤔&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        if (a == 1 &amp;amp;&amp;amp; a == 2 &amp;amp;&amp;amp; a == 3) {
            console.log(&#39;星空海绵&#39;);
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面写一段是什么代码可以让这个判断成立，执行打印的代码，首先一看到这个题目，大家应该想到，想要这个判断成立，a肯定得是一个变化得值，每使用一次就加1，那么这个判断才有可能成立，好了，怎样让这个判断成立的思路已经有了，现在的问题就是怎么让a每使用一次就加1呢。
首先我们来看一下&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E7%9B%B8%E7%AD%89&#34;&gt; == &lt;/a&gt;操作符成立的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.如果两个操作数都是对象，则仅当两个操作数都引用同一个对象时才返回true。&lt;/li&gt;
&lt;li&gt;2.如果一个操作数是null，另一个操作数是undefined，则返回true。&lt;/li&gt;
&lt;li&gt;3.如果两个操作数是不同类型的，就会尝试在比较之前将它们转换为相同类型：
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 1.当数字与字符串进行比较时，会尝试将字符串转换为数字值。&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 2.如果操作数之一是Boolean，则将布尔操作数转换为1或0。true转成1，false转成0。&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 3.如果操作数之一是对象，另一个是数字或字符串，会尝试使用对象的valueOf()和toString()方法将对象转换为原始值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4.如果操作数具有相同的类型，则将它们进行如下比较：
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 1.String：true仅当两个操作数具有相同顺序的相同字符时才返回。&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 2.Number：true仅当两个操作数具有相同的值时才返回。+0并被-0视为相同的值。如果任一操作数为NaN，则返回false。&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 3.Boolean：true仅当操作数为两个true或两个false时才返回true。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;== 运算符与 === 运算符之间的区别： === 运算符不尝试类型转换。相反， === 运算符始终将不同类型的操作数视为不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1第一种解法&#34;&gt;（1）第一种解法&lt;/h2&gt;
&lt;p&gt;看到上面 == 运算符的相关成立条件后，我们再来分析上面这一题，当 a 是 number 类型时，只有每次访问后都加1上面的判断才会成立。那么我们看下上面的代码，这个a没用var或者let及const定义，那就是隐式变量，当然我们也可在上面定义a，就单纯这个式子而言，a是隐式变量，隐式变量再浏览器中是挂在全局对象window下面的，也就是说a是window对象下的一个属性，然后对象有一个 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&#34;&gt;Object.defineProperty()&lt;/a&gt; 方法，这个方法能定义和修改一个对象上的属性，并且返回此对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let _default = 0
        Object.defineProperty(window, &#39;a&#39;, {
            get() {
                return ++_default;
            }
        })
        if (a == 1 &amp;amp;&amp;amp; a == 2 &amp;amp;&amp;amp; a == 3) {
            console.log(&#39;星空海绵&#39;);
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时通过上面这段代码我们发现这个判断成立，此时如果我们把 == 改成 === 成立吗，照样是成立的，因为此时a每次增加1并保持自己的类型为number，也就是说上面这段代码不仅适用于 == ，同时也适用于 === 。&lt;/p&gt;
&lt;h2 id=&#34;2第二种解法&#34;&gt;（2）第二种解法&lt;/h2&gt;
&lt;p&gt;看到上面 == 运算符的介绍，我们发现 &lt;strong&gt;如果操作数之一是对象，另一个是数字或字符串，会尝试使用对象的valueOf()和toString()方法将对象转换为原始值。&lt;/strong&gt; 有这么一个规则，也就是说假如现在上面的a是对象的话，会尝试使用valueOf方法和toSting方法，那么我们去修改这两个方法中的其中一个行吗&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let a = {
            _default: 0,
            valueOf: function () {
                return ++this._default;
            }
        }
        if (a == 1 &amp;amp;&amp;amp; a == 2 &amp;amp;&amp;amp; a == 3) {
            console.log(&#39;星空海绵&#39;);
        }
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;        let a = {
            _default: 0,
            toString: function () {
                return ++this._default;
            }
        }
        if (a == 1 &amp;amp;&amp;amp; a == 2 &amp;amp;&amp;amp; a == 3) {
            console.log(&#39;星空海绵&#39;);
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两种方法都可以，一个是重写a对象的valueOf方法，一个是重写对象的toString()方法。&lt;/p&gt;
&lt;h1 id=&#34;3深入类型转换&#34;&gt;3.深入类型转换&lt;/h1&gt;
&lt;p&gt;首先上题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        console.log(({} + {}).length);
        console.log(([] + []).length);
        console.log(([] + {}).length);
        console.log((function () { }).length);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这4个console分别打印什么，首先第一个其实是两个空对象相加，那么空对象怎么相加呢，它们会自动转成字符串相加，也就是调用toString方法，也就是说{}.toSting(),那么这个结果是什么呢，这个结果是 [object object]，此时你是不是想到了判断类型的 Object.prototype.toString.call() ,既然知道原理了，那第一个console的答案就是 &amp;ldquo;[object object]&amp;quot;+&amp;quot;[object object]&amp;quot;,也就是30，
第二个可能不用说大家都知道是0，因为[]空数组转换成数值类型是0，根据上面两题我们知道这个答案是 0+&amp;quot;[object object]&amp;quot;，也就是15，那么最后一题呢，我们不妨打印 console.dir(function () { }); 看一下，发现这个里面带了一个length属性，那么这个length属性是什么呢，其实是参数列表的个数，相当于 arguments.length,所以最后一个的结果也是0。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        console.log(({} + {}).length); // 30
        console.log(([] + []).length); // 0
        console.log(([] + {}).length); // 15
        console.log((function () { }).length); // 0
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;只是日常看到的，试着自己理解一下，我并不在乎这些题目是不是面试官为了装逼出出来难为面试者的，我只是看见了觉得好奇记录一下，请大佬们别打我！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;完！&lt;/strong&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS基础</title>
      <link>https://xkhm.net/post/css%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 29 Dec 2020 22:08:43 +0800</pubDate>
      
      <guid>https://xkhm.net/post/css%E5%9F%BA%E7%A1%80/</guid>
      
        <description>&lt;h1 id=&#34;1盒模型&#34;&gt;1.盒模型&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#%E8%A1%A5%E5%85%85_%E5%86%85%E9%83%A8%E5%92%8C%E5%A4%96%E9%83%A8%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B&#34;&gt;&lt;strong&gt;MDN 盒模型&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1什么是css-盒模型&#34;&gt;（1）.什么是CSS 盒模型?&lt;/h2&gt;
&lt;p&gt;块级盒子（Block box）和内联盒子（inline box）
完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。为了增加一些额外的复杂性，有一个标准的和替代（IE）的盒模型。&lt;/p&gt;
&lt;h2 id=&#34;2块级盒子的组成&#34;&gt;（2）块级盒子的组成&lt;/h2&gt;
&lt;p&gt;CSS中组成一个块级盒子需要:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height.&lt;/li&gt;
&lt;li&gt;Padding box: 包围在内容区域外部的空白区域； 大小通过 padding 相关属性设置。&lt;/li&gt;
&lt;li&gt;Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。&lt;/li&gt;
&lt;li&gt;Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3标准盒模型&#34;&gt;（3）标准盒模型&lt;/h2&gt;
&lt;p&gt;在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到margin。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4替代ie盒模型&#34;&gt;(4)替代（IE）盒模型&lt;/h2&gt;
&lt;p&gt;使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。
默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 box-sizing: border-box 来实现。 这样就可以告诉浏览器使用 border-box 来定义区域，从而设定您想要的大小。&lt;a href=&#34;https://codepen.io/yukiyukixing/pen/xxEpyNQ&#34;&gt;codepen&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;2bfc&#34;&gt;2.BFC&lt;/h1&gt;
&lt;p&gt;块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。使内外元素的隔离，定位不会互相影响。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根元素&lt;/li&gt;
&lt;li&gt;position: absolute/fixed&lt;/li&gt;
&lt;li&gt;display: inline-block / table&lt;/li&gt;
&lt;li&gt;float 元素&lt;/li&gt;
&lt;li&gt;ovevflow !== visible&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;position值（5个）：static | relative | absolute | sticky | fixed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻止margin重叠&lt;/li&gt;
&lt;li&gt;可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个div都位于同一个 BFC 区域之中)&lt;/li&gt;
&lt;li&gt;自适应两栏布局&lt;/li&gt;
&lt;li&gt;可以阻止元素被浮动元素覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3层叠上下文&#34;&gt;3.层叠上下文&lt;/h1&gt;
&lt;p&gt;个人理解，元素渲染出来后层级（前后）顺序，参考z-index&lt;/p&gt;
&lt;p&gt;触发条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根层叠上下文(html)&lt;/li&gt;
&lt;li&gt;position&lt;/li&gt;
&lt;li&gt;css3属性&lt;/li&gt;
&lt;li&gt;flex&lt;/li&gt;
&lt;li&gt;transform&lt;/li&gt;
&lt;li&gt;opacity&lt;/li&gt;
&lt;li&gt;filter&lt;/li&gt;
&lt;li&gt;will-change&lt;/li&gt;
&lt;li&gt;-webkit-overflow-scrolling&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4居中布局&#34;&gt;4.居中布局&lt;/h1&gt;
&lt;h2 id=&#34;1水平居中&#34;&gt;（1）水平居中&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;块级元素：margin:0 auto&lt;/li&gt;
&lt;li&gt;行内元素：text-align&lt;/li&gt;
&lt;li&gt;absolute + transform&lt;/li&gt;
&lt;li&gt;flex + justify-content: center &lt;a href=&#34;https://codepen.io/yukiyukixing/pen/BaLJGqm&#34;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2垂直居中&#34;&gt;（2）垂直居中&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;line-height:height&lt;/li&gt;
&lt;li&gt;absolute + transform&lt;/li&gt;
&lt;li&gt;flex + align-items: center&lt;/li&gt;
&lt;li&gt;table&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3水平垂直居中&#34;&gt;（3）水平垂直居中&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;absolute + transform&lt;/li&gt;
&lt;li&gt;flex + justify-content + align-items&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;absolute + transform垂直居中原理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.main {
    width: 300px;
    height: 300px;
    background-color: #50ba8b;
    position: relative;
}

.content {
    width: 150px;
    height: 150px;
    background-color: #5b4d4e;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置 .main 元素为相对定位 position: relative;，这样其子元素设置绝对定位时就相对它了。&lt;/li&gt;
&lt;li&gt;然后设置 .content 元素为绝对定位 position: absolute; 并设置 top: 50%;、left: 50%;，这样.content 元素的左上角就位于 .main 元素的中心了。&lt;/li&gt;
&lt;li&gt;最后设置 .content 元素 transform: translate(-50%, -50%); 将&lt;strong&gt;自身左移及上移宽高的一半&lt;/strong&gt;，这样 .content 元素的中心处于 .main 元素的中心处，自然就实现了居中效果。&lt;/li&gt;
&lt;li&gt;这种方法的好处就是不需要固定 .content 元素的宽高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5选择器优先级&#34;&gt;5.选择器优先级&lt;/h1&gt;
&lt;p&gt;!important &amp;gt; 内联样式 &amp;gt; ID选择器 &amp;gt; class选择器 &amp;gt; 标签选择器 &amp;gt; 通配符选择器 &amp;gt; 继承 &amp;gt; 默认&lt;/p&gt;
&lt;h1 id=&#34;6link-与-import-的区别&#34;&gt;6.link 与 @import 的区别&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载&lt;/li&gt;
&lt;li&gt;@import需要 IE5 以上才能使用&lt;/li&gt;
&lt;li&gt;link可以使用 js 动态引入，@import不行&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;7css动画&#34;&gt;7.CSS动画&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;transition&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;animation / keyframes&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS弹性盒子布局之Flex</title>
      <link>https://xkhm.net/post/css%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80%E4%B9%8Bflex/</link>
      <pubDate>Mon, 28 Dec 2020 22:59:54 +0800</pubDate>
      
      <guid>https://xkhm.net/post/css%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80%E4%B9%8Bflex/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;前言：flex布局永远滴神！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1css盒子弹性布局&#34;&gt;1.CSS盒子弹性布局&lt;/h1&gt;
&lt;p&gt;🤤弹性布局模型中，弹性容器的子元素可以在任何方向上排布，也可以“弹性伸缩”其尺寸，既可以增加尺寸以填满未使用的空间，也可以收缩尺寸避免父元素溢出。子元素的水平对齐和垂直对齐都能很方便的进行操控。通过嵌套这些框（水平框在垂直框内，或垂直框在水平框内）可以在两个维度上构建布局。——&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout&#34;&gt;MDN CSS 弹性盒子布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是 &lt;strong&gt;flexbox&lt;/strong&gt; 本质上是一种一维的布局，是因为一个 &lt;strong&gt;flexbox&lt;/strong&gt; 一次只能处理一个维度上的元素布局，一行或者一列，以上说的通过嵌套处理两个维度上的布局本质上还是处理了两个一维的布局。作为对比的是另外一个二维布局 &lt;strong&gt;CSS Grid Layout&lt;/strong&gt;，可以同时处理行和列上的布局。——&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox&#34;&gt;MDN flex 布局的基本概念&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;2flex布局&#34;&gt;2.flex布局&lt;/h1&gt;
&lt;p&gt;😎😎😎😎😎&lt;/p&gt;
&lt;h2 id=&#34;21-flex布局属性&#34;&gt;2.1 flex布局属性&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;属性&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;默认值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用对象&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-direction&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;定义了flex容器的主轴的方向(正方向或反方向)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;row，row-reverse，column，column-reverse&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;row&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-wrap&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;项目太大而无法全部显示在一行中，可以通过设置flex-wrap进行换行显示&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;nowrap，wrap，wrap-reverse，&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;nowrap&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-flow&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-direction 和 flex-wrap 组合简写属性 flex-flow&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上面两个属性值进行组合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;row nowrap&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;align-items&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-direction 和 flex-wrap 组合简写属性 flex-flow&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上面两个属性值进行组合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;row nowrap&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;justify-content&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-direction 和 flex-wrap 组合简写属性 flex-flow&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上面两个属性值进行组合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;row nowrap&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;align-content&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-direction 和 flex-wrap 组合简写属性 flex-flow&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上面两个属性值进行组合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;row nowrap&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-grow&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;为整数时，以 flex-basis 为基础，沿主轴方向增长尺寸&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;number&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex子项上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-shrink&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;处理flex子项收缩的问题&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;number&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex子项上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-basis&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;定义flex子项的空间大小&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;auto，number&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;auto&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex子项上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-grow，flex-shrink，flex-basis组合简写属性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex子项上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;order&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-grow，flex-shrink，flex-basis组合简写属性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex子项上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;align-self&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex-grow，flex-shrink，flex-basis组合简写属性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flex子项上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考文档：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1.&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout&#34;&gt;CSS 弹性盒子布局&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox&#34;&gt;flex 布局的基本概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>JS基础之Promise</title>
      <link>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8Bpromise/</link>
      <pubDate>Sat, 26 Dec 2020 16:05:58 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8Bpromise/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;前言：个人学习笔记，初识Promise&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1promise解决了什么问题&#34;&gt;1.Promise解决了什么问题？&lt;/h1&gt;
&lt;p&gt;用来解决 &lt;strong&gt;回调地狱&lt;/strong&gt; 问题&lt;/p&gt;
&lt;p&gt;回调地狱：在JS中，为了实现某些逻辑经常会写出层层嵌套的 &lt;strong&gt;回调函数&lt;/strong&gt;，如果嵌套过多，会极大的影响代码可读性和逻辑，这种情况被称为回调地狱。比如说把一个函数A作为回调函数，但是该函数又接收一个函数B作为参数，甚至B还能接受函数C作为参数，这样层层嵌套，人们称为&lt;strong&gt;回调地狱&lt;/strong&gt;，代码阅读性非常的差。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let sayHello = function (name, callback) {
            setTimeout(function () {
                console.log(name);
                callback();
            }, 1000);
        }
        sayHello(&#39;first&#39;, function () {
            sayHello(&#39;second&#39;, function () {
                sayHello(&#39;third&#39;, function () {
                    console.log(&#39;end&#39;);
                });
            });
        })
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;回调函数：回调是一个函数，它作为参数传递给另一个函数，并在其父函数完成后执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function doSomething(msg, callback) {
            alert(msg);
            if (typeof callback === &#39;function&#39;) {
                callback();
            }
        }
        doSomething(&#39;回调函数&#39;, function () {
            alert(&#39;匿名函数实现回调&#39;);
        });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;回调既可以同步回调，也可以异步回调。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        // 同步回调
        function getNodes(param, callback) {
            let list = JSON.stringify(param);
            if (typeof callback === &#39;function&#39;) {
                callback(list)
            }
        }
        getNodes(&#39;[1,2,3]&#39;, function (nodes) {
            console.log(nodes);
        });
        //ajax回调
        $.get(&#39;ajax/test.html&#39;, function (data) {
            $(&#39;box&#39;).html(data);
        })

        // 点击事件回调 
        $(&#39;#myBtn&#39;).click(function () {
            alert(&#39;click myBtn!&#39;);
        })
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;感受：JS虽然灵活，但是灵活的同时，带来的缺点就是，写代码的过程中需要加一些判断，比如上面这段代码中判断callback是不是函数，在别的强类型语言中，这个callback如果不是函数，可能写的时候编辑器就会直接提醒，传入参数的类型不对。所以就会出现TypeScript。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意回调函数中的this指向：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var clientData = {
            id: 096545,
            fullName: &amp;quot;Not Set&amp;quot;,
            setUserName: function (firstName, lastName) {
                this.fullName = firstName + &amp;quot; &amp;quot; + lastName;
            }
        }
        function getUserInput(firstName, lastName, callback) {
            //调用回调函数存储，此时是window调用的这个传进来的函数
            callback(firstName, lastName);
        }
        getUserInput(&amp;quot;Barack&amp;quot;, &amp;quot;Obama&amp;quot;, clientData.setUserName);
        console.log(clientData.fullName);  //Not Set
        console.log(window.fullName);  //Barack Obama
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这段代码中回调函数的this是指向window的，此时可以使用call或apply改下this的指向&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var clientData = {
            id: 096545,
            fullName: &amp;quot;Not Set&amp;quot;,
            setUserName: function (firstName, lastName) {
                this.fullName = firstName + &amp;quot; &amp;quot; + lastName;
            }
        }
        function getUserInput(firstName, lastName, callback) {
            //调用回调函数存储，此时是window调用的这个传进来的函数
            callback.call(clientData, firstName, lastName);
        }
        getUserInput(&amp;quot;Barack&amp;quot;, &amp;quot;Obama&amp;quot;, clientData.setUserName);
        console.log(clientData.fullName);  //Barack Obama
        console.log(window.fullName);  //undefined
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;问题：JS底层是怎么实现异步的，相关内容：V8引擎是如何实现异步的，EventLoop相关原理深度解析,JS执行过程中的堆栈变化，异步是不是等同于并行以及其它相关底层问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链式调用：&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS基础之手写bind</title>
      <link>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%89%8B%E5%86%99bind/</link>
      <pubDate>Fri, 25 Dec 2020 08:24:35 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%89%8B%E5%86%99bind/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;文章类型：学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1bind的使用&#34;&gt;1.bind()的使用&lt;/h1&gt;
&lt;p&gt;😏😏😏😏😏&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(name, job) {
            console.log(name);
            console.log(job);
            console.log(this.age);
        }
        getInfo.bind(obj, &#39;星空海绵&#39;)(&#39;Software Engineer&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;bind在第一个参数之后的参数，可以直接从bind()传,也可以从bind()返回的函数上传，如上代码。&lt;/p&gt;
&lt;h1 id=&#34;2bind参数&#34;&gt;2.bind()参数&lt;/h1&gt;
&lt;p&gt;🤔🤔🤔🤔🤔&lt;/p&gt;
&lt;h2 id=&#34;1thisarg&#34;&gt;（1）thisArg&lt;/h2&gt;
&lt;p&gt;bind的第一个参数是bind被函数调用时作为this参数传给调用函数。如果bind()参数列表为空，或者thisArg为null或undefined, &lt;strong&gt;执行作用域的this&lt;/strong&gt; 就是新函数的this。如果使用 &lt;strong&gt;new操作符&lt;/strong&gt; 操作绑定函数，则会 &lt;strong&gt;忽略这个thisArg参数&lt;/strong&gt; 。当使用bind在setTimeout中创建一个函数时，作为thisArg传递的任何原始值都会被转换为object。-&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&#34;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.bind的第一个参数是bind被函数调用时作为this参数传给调用函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo() {
            console.log(this); // {age: 18}
        }
        getInfo.bind(obj)();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时调用函数 getInfo 中的 this 就是 bind() 中传入的 obj&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.bind()参数列表为空，或者thisArg为null或undefined,执行作用域的this就是新函数的this&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo() {
            console.log(this); // Window {}
        }
        getInfo.bind()();
        getInfo.bind(null)();
        getInfo.bind(undefined)();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时bind的参数为 空 或 null 或 undefined，因为实际上 getInfo 是全局对象调用的，在这里也就是 window 对象，所以此时this就是指向 window 对象的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;3.如果使用new操作符操作绑定函数，则会忽略这个thisArg参数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo() {
            console.log(this); // getInfo {}
        }
        let a = getInfo.bind(obj)
        let b = new a();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时不管调用的时候传不传参数 obj，getInfo 中的 this 都是指向创建对象 b 的，这里就涉及到 new 构造函数创建对象的过程了，建议精读 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&#34;&gt;MDN&lt;/a&gt; 这部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4.当使用bind在setTimeout中创建一个函数时，作为thisArg传递的任何原始值都会被转换为object。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        function A() {
            this.name = &#39;星空海绵&#39;;
        }
        A.prototype.say = function () {
            setTimeout(this.read.bind(this), 1000)
        }
        A.prototype.read = function () {
            console.log(this.name);
        }
        let b = new A();
        b.say();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在默认情况下，使用 &lt;strong&gt;setTimeout()&lt;/strong&gt; 时，this 关键字会指向 window （或 global）对象。当类的方法中需要 this 指向类的实例时，你可能需要显式地把 this 绑定到回调函数，就不会丢失该实例的引用。&lt;/p&gt;
&lt;h2 id=&#34;2arg1-arg2-&#34;&gt;（2）arg1, arg2, &amp;hellip;&lt;/h2&gt;
&lt;p&gt;当bind被函数调用时，传给调用函数的参数列表&lt;/p&gt;
&lt;h1 id=&#34;3手写-bind&#34;&gt;3.手写 bind()&lt;/h1&gt;
&lt;p&gt;😎😎😎😎😎&lt;/p&gt;
&lt;h2 id=&#34;1不支持-new-调用-bind-返回的函数&#34;&gt;(1)不支持 new 调用 bind() 返回的函数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(name, job) {
            console.log(name);
            console.log(job);
            console.log(this);
            console.log(this.age);
        }
        // getInfo.call(obj, &#39;星空海绵&#39;, &#39;Software Engineer&#39;);
        Function.prototype.myBind = function (context) {
            var _that = this,
                slice = Array.prototype.slice,
                args = slice.call(arguments, 1);
            context = context || window;
            return function () {
                return _that.apply(context, args.concat(slice.call(arguments)))
            }
        }
        var a = getInfo.myBind(obj, &#39;星空海绵&#39;, &#39;Software Engineer&#39;),
            b = new a(), // 上面getInfo中的this打印结果为 obj 对象
            c = getInfo.bind(obj, &#39;星空海绵&#39;, &#39;Software Engineer&#39;),
            d = new c(); // 上面getInfo中的this打印结果为新创建的 d 对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的代码中我们可以看出来，此时当使用 new 调用时，并不会忽略掉传入的第一个参数 obj，调用函数的 this 一直是传入的第一个参数，不符合上面列举的原生的 bind() 第一个参数的第3条，当使用 new 调用时，会忽略第一个参数。&lt;/p&gt;
&lt;h2 id=&#34;2支持-new-调用&#34;&gt;(2)支持 new 调用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;上面第一种其实已完成了原生bind的基本功能，可以改变this指向了，但是不支持new调用的时候，那我们来思考一下为什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当使用 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&#34;&gt;new&lt;/a&gt; 调用我们写的myBind函数返回的函数时，这就是new通过构造函数创建一个对象的过程，&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&#34;&gt;MDN new创建对象过程&lt;/a&gt;                           &lt;br&gt;
1.首先创建一个空对象（{}）&lt;br&gt;
2.链接该对象（设置该对象的constructor）到另一个对象&lt;br&gt;
3.将步骤1新创建的对象作为this的上下文    &lt;br&gt;
4.如果该函数没有返回对象，则返回this&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看了上面new创建对象的过程，主要是第3步，将新创建的对象作为this的上下文，我们再看上面的代码，返回的函数中的this如果你去打印的话发现确实是空对象，符合上面new的创建过程，但是，下面一行用apply将调用函数getInfo中的this指向改到了传入的obj，这就不对了，所以说当用new调用的时候，此时就应该忽略obj，那么我们就需要判断new调用和不调用的时候就行了，ES6中有 new.target 可以判断一个函数是否被new调用过，那么ES5中是否有方法可以判断，没有的话那么模拟一个new.target就行了&lt;/p&gt;
&lt;p&gt;用new.target的话是下面这两种写法都行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(name, job) {
            console.log(name);
            console.log(job);
            console.log(this);
            console.log(this.age);
        }
        // getInfo.call(obj, &#39;星空海绵&#39;, &#39;Software Engineer&#39;);
        Function.prototype.myBind = function (context) {
            var _that = this,
                slice = Array.prototype.slice,
                args = slice.call(arguments, 1),
                obj = {};
            context = context || window;
            obj.__proto__.constructor = _that.prototype.constructor;
            return function () {
                if (new.target) {
                    return _that.apply(obj, args.concat(slice.call(arguments)))
                } else {
                    return _that.apply(context, args.concat(slice.call(arguments)))
                }

            }
        }
        var a = getInfo.myBind(obj, &#39;星空海绵&#39;, &#39;Software Engineer&#39;),
            b = new a(), // 上面getInfo中的this打印结果为 b 对象
            c = getInfo.bind(obj, &#39;星空海绵&#39;, &#39;Software Engineer&#39;),
            d = new c(); // 上面getInfo中的this打印结果为新创建的 d 对象
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;        Function.prototype.myBind = function (context) {
            var _that = this,
                args = [].slice.call(arguments, 1);
            context = context || window;
            return function () {
                if (new.target) {
                    return new _that(...args.concat(...arguments))
                } else {
                    return _that.apply(context, args.concat([].slice.call(arguments)))
                }

            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不使用 ES6 的new.target:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(name, job) {
            console.log(name);
            console.log(job);
            console.log(this);
            console.log(this.age);
        }
        // getInfo.call(obj, &#39;星空海绵&#39;, &#39;Software Engineer&#39;);
        Function.prototype.myBind = function (context) {
            var _that = this,
                args = [].slice.call(arguments, 1);
            context = context || window;
            return function F() {
                if (this instanceof F) {
                    return new _that(...[...args, ...arguments]);
                }
                return _that.apply(context, [...args, ...arguments])
            }
        }
        // getInfo.myBind(obj, &#39;星空海绵&#39;, &#39;Software Engineer&#39;)()
        var a = getInfo.myBind(obj, &#39;星空海绵&#39;, &#39;Software Engineer&#39;),
            b = new a(), // 上面getInfo中的this打印结果为 b 对象
            c = getInfo.bind(obj, &#39;星空海绵&#39;, &#39;Software Engineer&#39;),
            d = new c(); // 上面getInfo中的this打印结果为新创建的 d 对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中this如果在F构造函数的原型链上，那就证明使用new调用了myBind返回的构造函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总结：手写bind遇到new调用的问题，关键是需要理解new调用构造函数创建对象的过程。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>Vue从入门到出门</title>
      <link>https://xkhm.net/post/vue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%87%BA%E9%97%A8/</link>
      <pubDate>Thu, 24 Dec 2020 22:16:35 +0800</pubDate>
      
      <guid>https://xkhm.net/post/vue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%87%BA%E9%97%A8/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;前言：人家都开始上vue3.0了，我还在重学vue2.0，啊这🤡🤡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提醒：个人学习笔记，适合随手翻阅，精读需考量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1手摸手左手摸右手搭建一个vue的工程基于vue20&#34;&gt;1.手摸手（左手摸右手）搭建一个vue的工程，基于vue2.0&lt;/h1&gt;
&lt;p&gt;🔞🔞🔞🔞🔞&lt;/p&gt;
&lt;h2 id=&#34;1新建一个文件夹&#34;&gt;（1）新建一个文件夹😀😀&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d1cf5ccba04913bf4b636809d5ee02~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2执行-npm-install--g-vuecli-命令&#34;&gt;（2）执行 npm install -g @vue/cli 命令😋😋&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6c5d35990e94341894ebacb68f96d9c~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3执行-vue-create-vue-demo-命令&#34;&gt;（3）执行 vue create vue-demo 命令😥😥&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7921d90abba4179b73a61dcc1e30d36~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;
报错了，只需要去 D:\0.node\node_global\vue.ps1 图上报错的这个文件夹中将 vue.ps1 文件删掉再次运行这个命令即可&lt;/p&gt;
&lt;p&gt;项目搭建成功
&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91ca1f4024d1461a8337cde50ebdf42b~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;搭建成功😄😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2helloworld&#34;&gt;2.Hello,world!&lt;/h1&gt;
&lt;p&gt;🤔🤔🤔🤔🤔&lt;/p&gt;
&lt;h2 id=&#34;1运行-cd-vue-demo-和-npm-run-serve-&#34;&gt;（1）运行 cd vue-demo 和 npm run serve 😎😎&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1966c4de059444cbd86605ad086e724~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时，按住 ctrl+鼠标点击链接 就可以访问 vue 工程启动起来的页面了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb3b9a4cdc6547e381f60da95f2e10f7~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;页面上没有 Hello,world! 差评😠😠&lt;/p&gt;
&lt;h2 id=&#34;2自己写-helloworld-&#34;&gt;（2）自己写 Hello,world! 🤒🤒&lt;/h2&gt;
&lt;p&gt;修改HelloWorld文件：
&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f3840da6a84444195bc601d43cb4652~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;
修改路由文件：
&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7014f9bf75db4cdb80ccc8d5dcc21757~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;
Hello,world!
&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dfa2ada45a846d7bbf53edb9b01a7a9~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;好了，vue 算是已经进入了解的范围了，写过HelloWorld了，学任何一门语言不写个 Hello,world! 是不完整的，傲娇的野生程序员😒😒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;成就达成：了解Vue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;3开始照猫画虎之-cv-大法&#34;&gt;3.开始照猫画虎之 CV 大法&lt;/h1&gt;
&lt;p&gt;🤗🤗🤗🤗🤗&lt;/p&gt;
&lt;h2 id=&#34;1在-compoents-下新建一个-studyvue-文件&#34;&gt;（1）在 compoents 下新建一个 Study.vue 文件&lt;/h2&gt;
&lt;p&gt;将 HelloWorld.vue 中的文件拷贝过来，删删改改&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a774d3cdaa4029a32fee477997abd9~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2在-views-文件夹下新建一个-studyvue-文件&#34;&gt;（2）在 views 文件夹下新建一个 Study.vue 文件&lt;/h2&gt;
&lt;p&gt;将 Home.vue 中的代码拷贝过来改改&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb26fb389af7452c909ac54842b6843f~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3修改-router-下的-indexjs&#34;&gt;（3）修改 router 下的 index.js&lt;/h2&gt;
&lt;p&gt;拷贝一下数组里的第一个对象元素，改改
&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33ed35d599dc452ca1077cc11eb33631~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4修改-src-根目录下的-appvue-文件&#34;&gt;（4）修改 src 根目录下的 App.vue 文件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f2f98e56ee7408bac64d0eb464644be~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>js基础</title>
      <link>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 20 Dec 2020 23:48:22 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80/</guid>
      
        <description>&lt;h1 id=&#34;1js中的变量&#34;&gt;1.JS中的变量&lt;/h1&gt;
&lt;h2 id=&#34;1变量提升和函数提升&#34;&gt;（1）变量提升和函数提升&lt;/h2&gt;
&lt;p&gt;变量提升和函数提升的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建阶段：JS解释器会找出需要提升的变量和函数，并给他们在内存中开辟好空间，变量的话会声明并且赋值为undefined，而函数会整个存储在内存中&lt;/li&gt;
&lt;li&gt;代码执行阶段：就可以使用上面进行提升的变量和函数了&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：let也会提升，但是let存在暂时性死区，所以在声明之前不可使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2letvarconst区别&#34;&gt;（2）let，var，const区别&lt;/h2&gt;
&lt;p&gt;参考这篇文章：&lt;a href=&#34;https://www.cnblogs.com/yukixing/p/11523259.html&#34;&gt;let与var的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;let定义的变量不会挂载到window对象上，而是形成一个块作用域，而var定义的变量会挂在到window上&lt;/p&gt;
&lt;h1 id=&#34;2applycallbind&#34;&gt;2.apply，call，bind&lt;/h1&gt;
&lt;h2 id=&#34;1applycallbind作用&#34;&gt;（1）apply，call，bind作用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;改变函数内部的this指向&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2applycallbind区别&#34;&gt;（2）apply，call，bind区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;apply接收的是一个数组类型的参数，call和bind接收的是一个参数列表&lt;/li&gt;
&lt;li&gt;apply和call返回的是一个值结果，而bind返回的是一个函数，需要再次进行调用&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;语法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;apply&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;func.apply(thisArg, [argsArray])&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;this，数组或类数组对象&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;结果值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;call&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function.call(thisArg, arg1, arg2, &amp;hellip;)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;this，参数列表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;结果值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bind&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function.bind(thisArg, arg1, arg2, &amp;hellip;)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;this，参数列表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;bind()方法返回的函数没有prototype属性，为什么没有prototype属性呢，因为如果把这个返回的函数做构造函数的话，那就需要将创建对象的this指向这个函数，但是这个函数在bind调用前就将this指向调用对象了，那么创建对象时又将这个this指向创建对象，不就矛盾了吗，所以bind()返回的函数没有prototype属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this);
            this.d = 50;
        }
        Function.prototype.myBind = function () {
            if (typeof this !== &#39;function&#39;) {
                throw new TypeError(&#39;调用者必须是函数&#39;)
            }
            var arg = arguments[0],
                slice = Array.prototype.slice,
                args = slice.call(arguments, 1),
                _that = this;
            return function () {
                return _that.apply(arg, args.concat(slice.call(arguments)));
            }
        }
        var c = new getInfo.myBind(obj, &#39;Software Engineer&#39;); // Uncaught TypeError: 调用者必须是函数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果bind方法作为构造函数的话，那么它里面的this就需要指向创建的对象，而bind中的this必须指向函数，所以此时就会报错。&lt;/p&gt;
&lt;p&gt;apply，call，bind用法展示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18,
            job: &#39;student&#39;
        }
        function getInfo(name) {
            console.log(name); // 小花
            console.log(this.age); // 18
            console.log(this.job); // student
        }
        // getInfo.apply(obj, [&#39;小花&#39;]);
        // getInfo.call(obj, &#39;小花&#39;);
        getInfo.bind(obj, &#39;小花&#39;)();
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(job, height) {
            console.log(job);
            console.log(height);
            console.log(this.age);
        }
        getInfo.bind(obj, &#39;student&#39;)(173);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;3手写apply&#34;&gt;（3）手写apply()&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;小王&#39;
        }
        function getInfo(job) {
            console.log(this.name);
            console.log(job);
        }
        // getInfo.apply();
        Function.prototype.myApply = function (context) {
            context = context || window;
            context.fn = this;
            let result;
            if (arguments[1]) {
                if (Array.isArray(arguments[1])) {
                    result = context.fn(...arguments[1]);
                } else {
                    console.error(&#39;Uncaught TypeError: CreateListFromArrayLike called on non-object&#39;);
                }

            } else {
                result = context.fn()
            }
            delete context.fn;
            return result;
        }
        getInfo.myApply(obj, [&#39;student&#39;]);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;4手写call&#34;&gt;（4）手写call()&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(job, name) {
            console.log(job);
            console.log(name);
            console.log(this.age);
        }
        // getInfo.call(obj, &#39;student&#39;);
        Function.prototype.myCall = function (context) {
            context = context || window;
            context.fn = this;
            let result;
            if (arguments[1]) {
                result = context.fn(...[...arguments].slice(1));
            } else {
                result = context.fn();
            }
            delete context.fn;
            return result;
        }
        getInfo.myCall(obj, &#39;student&#39;, &#39;小王&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;5bind&#34;&gt;(5)bind()&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;bind()的使用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(job, height) {
            console.log(job);
            console.log(height);
            console.log(this.age);
        }
        getInfo.bind(obj, &#39;student&#39;)(173);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;bind()返回的函数用new操作符调用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        Point.prototype.toString = function () {
            return this.x + &#39;,&#39; + this.y;
        }
        let p = new Point(1, 2);
        p.toString();
        let emptyObj = {};
        let YAxisPoint = Point.bind(emptyObj, 0);
        let axisPoint = new YAxisPoint(5);
        axisPoint.toString();
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Polyfill中bind()的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第一种😎😎：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        if (!Function.prototype.bind) (function () {
            var slice = Array.prototype.slice;
            Function.prototype.bind = function () {
                var thatFunc = this, thatArg = arguments[0];
                var args = slice.call(arguments, 1);
                if (typeof thatFunc !== &#39;function&#39;) {
                    throw new TypeError(&#39;Function.prototype.bind-&#39; +
                        &#39;what is trying to be bound is not callable&#39;);
                }
                return function () {
                    var funcArgs = args.concat(slice.call(arguments));
                    return thatFunc.apply(thatArg, funcArgs);
                }
            }
        })()	
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;仿写这种实现bind():&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(name, job) {
            console.log(name);
            console.log(job);
            console.log(this.age);
        }
        // getInfo.bind(obj, &#39;星空海绵&#39;)(&#39;Software Engineer&#39;);
        Function.prototype.myBind = function () {
            if (typeof this !== &#39;function&#39;) {
                throw new TypeError(&#39;调用者必须是函数&#39;)
            }
            var arg = arguments[0];
            var slice = Array.prototype.slice
            var args = slice.call(arguments, 1);
            var _that = this;
            return function () {
                return _that.apply(arg, args.concat(slice.call(arguments)))
            }
        }
        getInfo.myBind(obj, &#39;星空海绵&#39;)(&#39;Software Engineer&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面定义变量为什么要用var呢，因为用的是ES5，如果用let，都有ES6了，那我就直接用bind()了，而不是手写一个了。&lt;/p&gt;
&lt;p&gt;我们会发现使用上面这种手写bind()不支持new调用构造函数创建新的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        Point.prototype.toString = function () {
            console.log(&#39;toString方法&#39;);
        }
        Function.prototype.myBind = function () {
            if (typeof this !== &#39;function&#39;) {
                throw new TypeError(&#39;调用者必须是函数&#39;)
            }
            var arg = arguments[0];
            var slice = Array.prototype.slice
            var args = slice.call(arguments, 1);
            var _that = this;
            return function () {
                return _that.apply(arg, args.concat(slice.call(arguments)))
            }
        }
        let YAxisPoint = Point.myBind({}, 0);
        let axisPoint = new YAxisPoint(5);
        console.dir(axisPoint);
        axisPoint.toString();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看下上面这个代码的axisPoint是啥&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4e2cae6d63c4622a787e1734edb84fb~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们再看如果把上面代码中的myBind换成bind&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14e226d3266743b79b34f21bb86c1cce~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是说上面这种写法不支持new调用构造函数创建新的对象，所以说有了下面第二种方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，当使用new操作符绑定构造函数时，会忽略第一个参数
&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a9fa4cd63af47e4a5a68e1ccaace639~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this); // {age: 25}
        }
        getInfo.bind(obj, &#39;Software Engineer&#39;)();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上是没有用new调用的时候，getInfo中的this是指向obj的，没问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function A() {
            this.a = 100;
            console.log(this); // {a: 100}
        }
        let b = new A();
        console.log(b); // {a: 100}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4457b0a1ef74335bae1ae5286bb35e0~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this); // getInfo {}
        }
        var a = getInfo.bind(obj, &#39;Software Engineer&#39;);
        var b = new a();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上的代码你会发现getInfo中的this并不是obj，而是getInfo对象，上面我们也看到有说，当使用new操作符号时会忽略掉第一个参数，也就是让调用bind的函数中的this指向的第一个参数被忽略掉，然后我们再想想bind的作用，不就是改变函数得this指向吗，现在第一个参数都忽略了，那么bind是不是相当于没用了，仔细想想，确实可以这个理解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this); // getInfo {}
        }
        var a = getInfo.bind(obj, &#39;Software Engineer&#39;);
        var b = new a();
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this); // getInfo {}
        }
        var b = new getInfo(&#39;Software Engineer&#39;);
        console.log(b);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相对而言，上面这两段代码其实通过构造函数创建的b对象时一样的，也就是说当使用了new操作符号时，bind就没用，就是单纯的返回一个函数。理解了这个我们就会明白为什么之前的代码会存在不知new调用构造函数创建新对象了，那么就有了第二种方法。&lt;/p&gt;
&lt;p&gt;当使用new调用构造函数时，构造函数中的this是指向新创建的对象的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种😯😯：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用ES6的new.target加以理解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this);
            this.d = 50;
        }
        Function.prototype.myBind = function () {
            if (typeof this !== &#39;function&#39;) {
                throw new TypeError(&#39;调用者必须是函数&#39;)
            }
            var arg = arguments[0],
                slice = Array.prototype.slice,
                args = slice.call(arguments, 1),
                _that = this;
            var fn1 = {};
            fn1 = new getInfo();
            return function () {
                if (new.target) {
                    return fn1
                } else {
                    return _that.apply(arg, args.concat(slice.call(arguments)));
                }
            }
        }
        var c = getInfo.myBind(obj, &#39;Software Engineer&#39;);
        var d = new c();
        console.log(d);
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;3原型链&#34;&gt;3.原型链&lt;/h1&gt;
&lt;h2 id=&#34;1对象和函数的原型&#34;&gt;（1）对象和函数的原型&lt;/h2&gt;
&lt;p&gt;每个对象都有一个原型，但是原型没有提供可以直接访问的属性，所以浏览器实现了一个__proto__属性，可以直接访问到对象的原型，每个函数都有一个__proto__和prototype属性，当函数当对象使用时，原型是__proto__，当函数作为构造函数使用时，原型是prototype。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当函数作为对象使用时&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        function Demo() { }
        Demo.__proto__.show = function () {
            console.log(&amp;quot;__proto__show&amp;quot;);
        }
        Demo.prototype.read = function () {
            console.log(&amp;quot;prototype-read&amp;quot;);
        }
        Demo.show();  // __proto__show
        Demo.read(); // Demo.read is not a function
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;当函数作为构造函数使用时&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        function Demo() { }
        let obj = new Demo();
        Demo.prototype.read = function () {
            console.log(&amp;quot;read&amp;quot;);
        }
        Demo.__proto__.show = function () {
            console.log(&amp;quot;show&amp;quot;);
        }
        obj.read(); // read
        obj.show(); // obj.show is not a function
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2原型链&#34;&gt;（2）原型链&lt;/h2&gt;
&lt;p&gt;对象可以通过__proto__属性找到不属于该对象的属性，__proto__将对象连接起来组成了原型链。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function A() { }
        function B() { }
        function C() { }
        C.prototype.show = function () {
            console.log(&#39;C构造函数&#39;);
        }
        B.prototype = new C();
        A.prototype = new B();
        let a = new A();
        a.show(); // C构造函数
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;4如何判断对象类型&#34;&gt;4.如何判断对象类型&lt;/h1&gt;
&lt;h2 id=&#34;1通过-objectprototypetostringcall&#34;&gt;（1）通过 Object.prototype.toString.call()&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 20
        }
        let arr = [15, 20, 25];
        console.log(Object.prototype.toString.call(obj)); // [object Object]
        console.log(Object.prototype.toString.call(arr)); // [object Array]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2通过instanceof&#34;&gt;（2）通过instanceof&lt;/h2&gt;
&lt;p&gt;instanceof检测构造函数的prototype属性是不是出现在某个对象的原型链上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function A() { };
        function B() { };
        const b = new B();
        A.prototype = b;
        const a = new A();
        console.dir(a instanceof A); // true
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;5箭头函数&#34;&gt;5.箭头函数&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        var age = 10;
        let obj = {
            age: 20,
            say: () =&amp;gt; {
                return this.age;
            }
        }
        console.log(obj.say()); // 10
        let obj1 = {
            age: 30
        }
        obj1 = Object.create(obj);
        obj1.age = 30;
        console.log(obj1.say()); // 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过上面的代码我们会发现箭头函数say中的this并不会因为调用对象的改变而改变，而是一直指向全局对象window的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function getName() {
            let say = () =&amp;gt; {
                console.log(this.age);
            }
            say();
        }
        let obj = {
            age: 20,
            getName: getName
        }
        obj.getName(); // 20
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;箭头函数没有自己的this，它只会从自己作用域链的上层继承this。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;箭头函数中不能使用arguments和super以及new.target，同时箭头函数也不能作为构造函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;6this&#34;&gt;6.this&lt;/h1&gt;
&lt;h2 id=&#34;1谁调用函数函数里得this就指向谁&#34;&gt;（1）谁调用函数，函数里得this就指向谁&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        function getAge() {
            console.log(this.age)
        }
        var age = 1
        getAge()

        var obj = {
            age: 2,
            getAge: getAge
        }
        obj.getAge()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2new构造函数创建对象时构造函数内部的this指向创建的对象&#34;&gt;（2）new构造函数创建对象时，构造函数内部的this指向创建的对象&lt;/h2&gt;
&lt;h2 id=&#34;3可以通过applycallbind来改变函数内部的this指向&#34;&gt;（3）可以通过apply，call，bind来改变函数内部的this指向&lt;/h2&gt;
&lt;h1 id=&#34;7async和await&#34;&gt;7.async和await&lt;/h1&gt;
&lt;h2 id=&#34;1async和await对比promise&#34;&gt;（1）async和await对比Promise&lt;/h2&gt;
&lt;p&gt;async和await相比Promise，优势在于处理then调用链，代码更清晰，缺点是乱用await会导致性能问题，因为await会阻塞代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var a = 0;
        var b = async () =&amp;gt; {
            a = a + await 10;
            console.log(&#39;2&#39;, a);
            a = (await 10) + a;
            console.log(&#39;3&#39;, a);
        }
        b();
        a++;
        console.log(&#39;1&#39;, a);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;待深入&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;8generator&#34;&gt;8.generator&lt;/h1&gt;
&lt;h2 id=&#34;1generator是es6中新增的语法和promise一样都可以用来进行异步编程&#34;&gt;(1)generator是ES6中新增的语法，和Promise一样，都可以用来进行异步编程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        function* test() {
            let a = 1 + 2;
            yield 2;
            yield 3;
        }
        let b = test();
        console.log(b.next());
        console.log(b.next());
        console.log(b.next());
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2generator原理手写generator&#34;&gt;（2）generator原理，手写generator&lt;/h2&gt;
&lt;h1 id=&#34;9promise&#34;&gt;9.Promise&lt;/h1&gt;
&lt;h2 id=&#34;1promise是es6中新增的语法用来解决回调地狱问题&#34;&gt;（1）Promise是ES6中新增的语法，用来解决&lt;strong&gt;回调地狱&lt;/strong&gt;问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;什么是回调地狱？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2手写promise&#34;&gt;（2）手写Promise&lt;/h2&gt;
&lt;h1 id=&#34;10--和--的区别&#34;&gt;10. == 和 === 的区别&lt;/h1&gt;
&lt;p&gt;==只需要值相等即可，而 === 需要值和类型都相等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;11-垃圾回收&#34;&gt;11. 垃圾回收&lt;/h1&gt;
&lt;p&gt;主要的两种标记策略：&lt;strong&gt;标记清理&lt;/strong&gt; 和 &lt;strong&gt;引用计数&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;1标记清理&#34;&gt;（1）标记清理&lt;/h2&gt;
&lt;p&gt;JS最常用的垃圾回收策略就是标记清理。&lt;/p&gt;
&lt;p&gt;标记方法可以有多种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以当变量进入上下文中，反转某一位&lt;/li&gt;
&lt;li&gt;也可以维护“在上下文中”和“不在上下文中”这样的两个变量列表，可以把变量从一个列表移到另一个列表&lt;/li&gt;
&lt;li&gt;其它&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;垃圾回收程序运行时，会标记内存中存储的所有变量，然后，它会将所有上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是有待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。&lt;/p&gt;
&lt;h2 id=&#34;2引用计数&#34;&gt;（2）引用计数&lt;/h2&gt;
&lt;p&gt;另一种没那么常用的策略就是引用计数。&lt;/p&gt;
&lt;p&gt;引用计数存在解决不了循环引用的问题&lt;/p&gt;
&lt;h1 id=&#34;12闭包&#34;&gt;12.闭包&lt;/h1&gt;
&lt;h2 id=&#34;1定义&#34;&gt;（1）定义&lt;/h2&gt;
&lt;p&gt;函数A返回函数B，函数B中使用了函数A中的变量，函数B就被称为闭包。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function A() {
            let age = 10;
            return function B() {
                console.log(age);
            }
        }
        A()();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这个例子age变量是存储在堆上的，因为JS的引擎可以分析出哪些变量需要存储在堆上，哪些变量需要存储在栈上。&lt;/p&gt;
&lt;p&gt;通过闭包解决变量作用域的问题，例如：解决var没有块作用域的问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        for (var i = 0; i &amp;lt; 4; i++) {
            (function (j) {
                setTimeout(function () {
                    console.log(j);
                })
            }
            )(i)
        }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2闭包的内存泄漏问题&#34;&gt;（2）闭包的内存泄漏问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用JS闭包很容易在不知不觉间造成内存泄漏问题&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        let outer = function () {
            let name = &#39;Jake&#39;;
            return function () {
                return name;
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这段代码调用outer()会导致分配给name的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理name，因为闭包一直在引用着它，假如name的内容很大，那可能就是个大问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;13基本类型和引用类型&#34;&gt;13.基本类型和引用类型&lt;/h1&gt;
&lt;p&gt;基础类型存储在栈上，引用类型的地址存储在栈上，内容存储在堆上&lt;/p&gt;
&lt;h1 id=&#34;14eventloop&#34;&gt;14.Eventloop&lt;/h1&gt;
&lt;h2 id=&#34;1为什么js是单线程的&#34;&gt;（1）为什么JS是单线程的&lt;/h2&gt;
&lt;p&gt;作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这就决定了它只能是单线程，否则的话就会出现很多复杂的同步问题。假设JS有两个线程，一个线程往某个dom节点上添加内容，一个线程删除这个节点，那么应该以哪个线程为主呢，所以JS是单线程的就不会出现这种情况。&lt;/p&gt;
&lt;p&gt;JS并发事件模型&lt;/p&gt;
&lt;h2 id=&#34;1什么是eventloop&#34;&gt;（1）什么是Eventloop&lt;/h2&gt;
&lt;p&gt;主线程从&amp;quot;任务队列&amp;quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）&lt;/p&gt;
&lt;h2 id=&#34;2微任务和宏任务&#34;&gt;（2）微任务和宏任务&lt;/h2&gt;
&lt;h1 id=&#34;15回调函数&#34;&gt;15.回调函数&lt;/h1&gt;
&lt;h1 id=&#34;16settimeout&#34;&gt;16.setTimeout&lt;/h1&gt;
&lt;h2 id=&#34;1settimeout倒计时误差&#34;&gt;（1）setTimeout倒计时误差&lt;/h2&gt;
&lt;p&gt;为什么会出现这个问题呢，从刚才上面的JS事件循环机制我们就可以了解到，只有等同步任务全部执行完了才会执行异步任务，而setTimeout是一个宏任务，那么这个问题的实际应用在哪呢，电商的秒杀倒计时，那个肯定要准确，不同用户可能因为手机的性能加载页面的时长不一样，但是秒杀时间肯定得一样，所以说我们就需要写一个相对准确的倒计时了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(() =&amp;gt; {}, 3000);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有一行上面这样的代码，这不是说页面打开3秒后立即执行回调函数，而是页面打开后最快3秒执行回调函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        console.log(Date());
        setTimeout(() =&amp;gt; {
            console.log(&#39;我是定时器！&#39;);
            console.log(Date());
        }, 3000);
        for (let i = 0; i &amp;lt; 10000000000; i++) { }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你电脑性能好的话可以跑下上面这个例子，你会发现间隔时间并不是3秒&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f09409fa20dd411a9d5e0652354caca5~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;看我这打印的结果，中间差了14秒，这是为什么呢，因为执行前面的循环花费了很长的时间，setTimeout必须等循环执行完才会去执行自己的回调函数，所以这时候这个倒计时就不准确了，就需要我们自己写一个倒计时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let period = 60 * 1000 * 60 * 2,
            startTime = new Date().getTime(),
            count = 0,
            end = new Date().getTime() + period,
            interval = 1000,
            currentInterval = interval;
        function loop() {
            count++;
            let offset = new Date().getTime() - (startTime + count * interval),
                diff = end - new Date().getTime(),
                h = Math.floor(diff / (60 * 1000 * 60)),
                hdiff = diff % (60 * 1000 * 60),
                m = Math.floor(hdiff / (60 * 1000)),
                mdiff = hdiff % (60 * 1000),
                s = mdiff / (1000),
                sCeil = Math.ceil(s),
                sFloor = Math.floor(s),
                currentInterval = interval - offset;
            console.log(&#39;时：&#39; + h, &#39;分：&#39; + m, &#39;毫秒：&#39; + s,
                &#39;秒向上取整：&#39; + sCeil, &#39;代码执行时间：&#39; + offset,
                &#39;下次循环间隔&#39; + currentInterval)
            // 打印 时 分 秒 代码执行时间 下次循环间隔
            setTimeout(loop, currentInterval)
        }
        loop();
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;17防抖节流&#34;&gt;17.防抖节流&lt;/h1&gt;
&lt;h1 id=&#34;18数组降维&#34;&gt;18.数组降维&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat&#34;&gt;MDN参考&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1使用-es10-中的-flat&#34;&gt;（1）使用 &lt;strong&gt;ES10&lt;/strong&gt; 中的 &lt;strong&gt;flat()&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [50, 20, [50, 10, [1, [5, [20]]]]],
            arr1 = arr.flat(Infinity);
        console.log(arr); // [50, 20, Array(3)]
        console.log(arr1); //  [50, 20, 50, 10, 1, 5, 20]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2递归&#34;&gt;（2）递归&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [50, 20, [50, 10, [1, [5, [20]]]]],
            resArray = [];
        function flatten(array) {
            if (Array.isArray(array) === false) {
                throw new TypeError(&#39;参数类型错误&#39;);
            }
            array.forEach(item =&amp;gt; {
                if (Array.isArray(item)) {
                    flatten(item);
                } else {
                    resArray.push(item)
                }
            })
            return resArray;
        }
        console.log(arr); // [50, 20, Array(3)]
        console.log(flatten(arr)); // [50, 20, 50, 10, 1, 5, 20]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;3&#34;&gt;（3）&lt;/h2&gt;
</description>
      
    </item>
    
    <item>
      <title>JS数组去重</title>
      <link>https://xkhm.net/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Sun, 20 Dec 2020 18:12:21 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;文章类型：个人学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1双循环遍历&#34;&gt;1.双循环遍历&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1,5,6,1,9,9,2,1];
        arr.map((item,index) =&amp;gt; {
            arr.map((i,index1) =&amp;gt; {
                if(index !== index1 &amp;amp;&amp;amp; item === i){
                    arr.splice(index1,1);
                }
            })
        })
        console.log(arr);
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;        function unique(array){
            for (let i = 0; i &amp;lt; array.length; i++) {
                for(let j = i+1; j &amp;lt; array.length; j++){
                    if(array[i] === array[j]){
                        arr.splice(j,1);
                    }
                }
            }
            return arr;
        }
        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;下面一种方式更优，遍历的次数更少&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2-es6的set&#34;&gt;2. ES6的Set&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1,5,6,1,9,9,2,1];
        function unique(arr) {
            return Array.from(new Set(arr))
        }
        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;        let arr = [1, 5, 6, 1, 9, 9, 9, 9, 9, 2, 1];
        function unique(arr) {
            return [...new Set(arr)]
        }
        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;3利用indexof&#34;&gt;3.利用indexOf()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1,5,6,1,9,9,2,1];
        function unique(arr){
            if(!Array.isArray(arr)){
                console.log(&#39;type error&#39;);
                return;
            }
            let array = [];
            arr.map(item =&amp;gt; {
                if(array.indexOf(item) === -1){
                    array.push(item)
                }
            })
            return array;
        }
        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;4利用sort然后比较相邻元素是否相等&#34;&gt;4.利用sort(),然后比较相邻元素是否相等&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1, 5, 6, 1, 9, 9, 9, 9, 9, 2, 1];
        function unique(arr) {
            if (!Array.isArray(arr)) {
                console.log(&#39;type error!&#39;)
                return;
            }
            arr = arr.sort()
            let arrry = [arr[0]];
            arr.map((item, index) =&amp;gt; {
                if (index &amp;gt; 0 &amp;amp;&amp;amp; item !== arr[index - 1]) {
                    arrry.push(item)
                }
            });
            return arrry;
        }
        console.log(unique(arr)); // [1, 2, 5, 6, 9]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;5利用filter当找到的下标不等于当前下标时就证明这个元素在前面出现过排除掉&#34;&gt;5.利用filter(),当找到的下标不等于当前下标时就证明这个元素在前面出现过，排除掉&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1, 5, 6, 1, 9, 9, 9, 9, 9, 2, 1];
        function unique(arr) {
            if (!Array.isArray(arr)) {
                console.log(&#39;type error!&#39;)
                return;
            }
            return arr.filter((item, index) =&amp;gt; {
                return arr.indexOf(item) === index;
            })
        }

        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;秒啊！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;6利用reduce方法&#34;&gt;6.利用reduce()方法&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1, 5, 6, 1, 9, 9, 9, 9, 9, 2, 1];
        function unique(arr) {
            if (!Array.isArray(arr)) {
                console.log(&#39;type error!&#39;)
                return;
            }
            return arr.reduce((prev, cur, index) =&amp;gt; prev.includes(cur) ? prev : [...prev, cur], []);
        }

        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;秀啊！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;总结：ES6下，以上几种方法首选第二种 new Set(),其次选择filter()和reduce()&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>日常小记</title>
      <link>https://xkhm.net/essaycontent/%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sat, 19 Dec 2020 23:01:15 +0800</pubDate>
      
      <guid>https://xkhm.net/essaycontent/%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%AE%B0/</guid>
      
        <description>&lt;h1 id=&#34;随笔&#34;&gt;随笔&lt;/h1&gt;
</description>
      
    </item>
    
    <item>
      <title>船到桥头自然直</title>
      <link>https://xkhm.net/lifecontent/%E8%88%B9%E5%88%B0%E6%A1%A5%E5%A4%B4%E8%87%AA%E7%84%B6%E7%9B%B4/</link>
      <pubDate>Sat, 19 Dec 2020 22:57:52 +0800</pubDate>
      
      <guid>https://xkhm.net/lifecontent/%E8%88%B9%E5%88%B0%E6%A1%A5%E5%A4%B4%E8%87%AA%E7%84%B6%E7%9B%B4/</guid>
      
        <description>&lt;h1 id=&#34;船到桥头自然直-all-will-be-good&#34;&gt;船到桥头自然直 All will be good&lt;/h1&gt;
</description>
      
    </item>
    
  </channel>
</rss>
