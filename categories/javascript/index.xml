<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on 星空海绵 - 星空浩瀚 | 海绵吸水</title>
    <link>https://xkhm.net/categories/javascript/</link>
    <description>Recent content in JavaScript on 星空海绵 - 星空浩瀚 | 海绵吸水</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>星空海绵</copyright>
    <lastBuildDate>Thu, 14 Jan 2021 23:14:19 +0800</lastBuildDate><atom:link href="https://xkhm.net/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>从一场比赛大话JS面向对象的思想</title>
      <link>https://xkhm.net/post/%E4%BB%8E%E4%B8%80%E5%9C%BA%E6%AF%94%E8%B5%9B%E5%A4%A7%E8%AF%9Djs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E6%83%B3/</link>
      <pubDate>Thu, 14 Jan 2021 23:14:19 +0800</pubDate>
      
      <guid>https://xkhm.net/post/%E4%BB%8E%E4%B8%80%E5%9C%BA%E6%AF%94%E8%B5%9B%E5%A4%A7%E8%AF%9Djs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E6%83%B3/</guid>
      <description>前言：最近再看JS对象相关的东西，看到继承那，想继承到底有什么用，就搜了以下，搜到了下面这个故事，然后突发奇想，能不能用JS实现以下呢，然后</description>
    </item>
    
    <item>
      <title>JS基础之继承</title>
      <link>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Thu, 14 Jan 2021 08:35:17 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%A7%E6%89%BF/</guid>
      <description>1.继承 // 1. 原型链继承 function A() { } function B() { } B.prototype = new A(); let a = new B(); // 2. 经典继承 function A() { } function B() { A.call(this) } let a = new B(); // 3.组合继承 function A() { } function B() { A.call(this) } B.prototype = new A(); let a</description>
    </item>
    
    <item>
      <title>定型数组</title>
      <link>https://xkhm.net/post/%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 12 Jan 2021 21:21:51 +0800</pubDate>
      
      <guid>https://xkhm.net/post/%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84/</guid>
      <description>1.定型数组 定型数组是ES新增的结构，目的是提升向原生库传输数据的效率。本质上是一种包含数值类型的数组。 （1）历史 随着浏览器的流行，需要使用</description>
    </item>
    
    <item>
      <title>手写Promise</title>
      <link>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%89%8B%E5%86%99promise/</link>
      <pubDate>Thu, 07 Jan 2021 21:50:29 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%89%8B%E5%86%99promise/</guid>
      <description>文章类型：个人学习笔记 手写 Promise 的前提是了解 Promise/A+ 规范，不说倒背如流，但是基本的点还是需要掌握的。 1.Promise/A+规范 原文地址：Promis</description>
    </item>
    
    <item>
      <title>JavaScript异步编程</title>
      <link>https://xkhm.net/post/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 04 Jan 2021 22:56:54 +0800</pubDate>
      
      <guid>https://xkhm.net/post/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</guid>
      <description>1.什么是异步？ (1)异步的作用 在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中</description>
    </item>
    
    <item>
      <title>JS面试题复习</title>
      <link>https://xkhm.net/post/js%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Mon, 04 Jan 2021 08:30:30 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%8D%E4%B9%A0/</guid>
      <description>1.对象 （1）深浅拷贝 只会拷贝对象的第一层 1.浅拷贝（4种） （1）直接赋值 let obj = { name: &amp;#39;XKHM&amp;#39;, age: 25, job: &amp;#39;Software Engineer&amp;#39; } let obj1 = obj; console.log(obj1 === obj); （2）Object.assi</description>
    </item>
    
    <item>
      <title>JS之日常解题</title>
      <link>https://xkhm.net/post/js%E4%B9%8B%E6%97%A5%E5%B8%B8%E8%A7%A3%E9%A2%98/</link>
      <pubDate>Thu, 31 Dec 2020 22:06:11 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E4%B9%8B%E6%97%A5%E5%B8%B8%E8%A7%A3%E9%A2%98/</guid>
      <description>前言：好记性不如烂笔头，知识来自于点点滴滴的记录 1.取出对象中一部分放到另一个对象中 今天下午在掘金摸鱼的时候，看见有一个小同学发了一个沸点 嗯</description>
    </item>
    
    <item>
      <title>JS基础之Promise</title>
      <link>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8Bpromise/</link>
      <pubDate>Sat, 26 Dec 2020 16:05:58 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8Bpromise/</guid>
      <description>前言：个人学习笔记，初识Promise 1.Promise解决了什么问题？ 用来解决 回调地狱 问题 回调地狱：在JS中，为了实现某些逻辑经常会写出层</description>
    </item>
    
    <item>
      <title>JS基础之手写bind</title>
      <link>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%89%8B%E5%86%99bind/</link>
      <pubDate>Fri, 25 Dec 2020 08:24:35 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%89%8B%E5%86%99bind/</guid>
      <description>文章类型：学习笔记 1.bind()的使用 😏😏😏😏😏 let obj = { age: 18 } function getInfo(name, job) { console.log(name); console.log(job); console.log(this.age); } getInfo.bind(obj, &#39;星空海绵&#39;)(&#39;Software Engineer&#39;); bind在第一个参数之</description>
    </item>
    
    <item>
      <title>JS数组去重</title>
      <link>https://xkhm.net/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Sun, 20 Dec 2020 18:12:21 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
      <description>文章类型：个人学习笔记 1.双循环遍历 let arr = [1,5,6,1,9,9,2,1]; arr.map((item,index) =&amp;gt; { arr.map((i,index1) =&amp;gt; { if(index !== index1 &amp;amp;&amp;amp; item === i){ arr.splice(index1,1); } }) }) console.log(arr); function unique(array){ for (let i = 0; i &amp;lt; array.length; i++) { for(let j = i+1; j &amp;lt; array.length; j++){ if(array[i] === array[j]){ arr.splice(j,1); } } } return arr; }</description>
    </item>
    
  </channel>
</rss>
