<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>JS基础之Promise - 星空海绵 - 星空浩瀚 | 海绵吸水</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="XKHM" />
  <meta name="description" content="前言：个人学习笔记，初识Promise 1.Promise解决了什么问题？ 用来解决 回调地狱 问题 回调地狱：在JS中，为了实现某些逻辑经常会写出层" />

  <meta name="keywords" content="Hugo, 星空海绵, 前端, 工程师" />






<meta name="generator" content="Hugo 0.79.0" />


<link rel="canonical" href="https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8Bpromise/" />





<link rel="icon" href="/favicon.png" type="image/x-icon"/>











<link rel="stylesheet" href="/sass/jane.min.f1e506a781bf25d33ffc18aa6b4e972a965c58049d27d4f92b7db2e9bf28e4bf.css" integrity="sha256-8eUGp4G/JdM//Biqa06XKpZcWASdJ9T5K32y6b8o5L8=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="JS基础之Promise" />
<meta property="og:description" content="前言：个人学习笔记，初识Promise 1.Promise解决了什么问题？ 用来解决 回调地狱 问题 回调地狱：在JS中，为了实现某些逻辑经常会写出层" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8Bpromise/" />
<meta property="article:published_time" content="2020-12-26T16:05:58+08:00" />
<meta property="article:modified_time" content="2020-12-26T16:05:58+08:00" />
<meta itemprop="name" content="JS基础之Promise">
<meta itemprop="description" content="前言：个人学习笔记，初识Promise 1.Promise解决了什么问题？ 用来解决 回调地狱 问题 回调地狱：在JS中，为了实现某些逻辑经常会写出层">
<meta itemprop="datePublished" content="2020-12-26T16:05:58+08:00" />
<meta itemprop="dateModified" content="2020-12-26T16:05:58+08:00" />
<meta itemprop="wordCount" content="6567">



<meta itemprop="keywords" content="JavaScript,Promise,异步回调," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JS基础之Promise"/>
<meta name="twitter:description" content="前言：个人学习笔记，初识Promise 1.Promise解决了什么问题？ 用来解决 回调地狱 问题 回调地狱：在JS中，为了实现某些逻辑经常会写出层"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-K0V0BST0TH', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">星空海绵</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/">首页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/treasury/">细品</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/interview/">提桶</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/life/">生活</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/readbook/">读书</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/technology/">技术</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/essay/">思考</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/tobedone/">Flag</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/about/">关于</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/tags/">标签</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      星空海绵
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/">首页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/treasury/">细品</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/interview/">提桶</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/life/">生活</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/readbook/">读书</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/technology/">技术</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/essay/">思考</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/tobedone/">Flag</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/about/">关于</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://xkhm.net/tags/">标签</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">JS基础之Promise</h1>
      
      <div class="post-meta">
        <time datetime="2020-12-26" class="post-time">
          2020-12-26
        </time>
        <div class="post-category">
            <a href="https://xkhm.net/categories/javascript/"> JavaScript </a>
            
          </div>
        <span class="more-meta"> 约 6567 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1promise特点">（1）Promise特点</a></li>
    <li><a href="#2链式调用">（2）链式调用</a></li>
    <li><a href="#3catch-的后续链式操作">(3)Catch 的后续链式操作</a></li>
    <li><a href="#4错误传递">（4）错误传递</a></li>
    <li><a href="#5promise-拒绝事件">（5）Promise 拒绝事件</a>
      <ul>
        <li><a href="#1rejectionhandled">（1）rejectionhandled</a></li>
        <li><a href="#2unhandledrejection">（2）unhandledrejection</a></li>
      </ul>
    </li>
    <li><a href="#6在旧式回调-api-中创建-promise">（6）在旧式回调 API 中创建 Promise</a></li>
    <li><a href="#7组合">（7）组合</a></li>
    <li><a href="#8时序">8.时序</a></li>
    <li><a href="#9嵌套">9.嵌套</a></li>
    <li><a href="#10常见错误">10.常见错误</a></li>
  </ul>

  <ul>
    <li><a href="#1promise状态">（1）Promise状态</a></li>
    <li><a href="#2promise构造函数">（2）Promise()构造函数</a></li>
  </ul>

  <ul>
    <li><a href="#1promiseall">（1）Promise.all()</a></li>
    <li><a href="#2promiseallsettled">（2）Promise.allSettled()</a></li>
    <li><a href="#3promiseany">（3）Promise.any()</a></li>
    <li><a href="#4promiserace">（4）Promise.race()</a></li>
    <li><a href="#5promisereject">（5）Promise.reject()</a></li>
    <li><a href="#6promiseresolve">（6）Promise.resolve()</a></li>
  </ul>

  <ul>
    <li><a href="#1promiseprototypecatch">（1）Promise.prototype.catch()</a></li>
    <li><a href="#2promiseprototypethen">（2）Promise.prototype.then()</a></li>
    <li><a href="#3promiseprototypefinally">（3）Promise.prototype.finally()</a></li>
  </ul>

  <ul>
    <li><a href="#1promisethen里抛出的错误能否被trycatch捕获为什么">（1）Promise.then里抛出的错误能否被try&hellip;catch捕获，为什么？</a></li>
    <li><a href="#2你怎么解决回掉地狱的问题你对proxy和promise的理解在哪里用到过">（2）你怎么解决“回掉地狱”的问题？你对Proxy，和Promise的理解，在哪里用到过？</a></li>
    <li><a href="#3请手写实现一个-promise">（3）请手写实现一个 promise？</a></li>
    <li><a href="#4淘宝等网站的倒计时功能如何实现">（4）淘宝等网站的倒计时功能如何实现？</a></li>
    <li><a href="#5写一个-promise-重试函数可以设置时间间隔和次数">（5）写一个 promise 重试函数，可以设置时间间隔和次数</a></li>
    <li><a href="#6手写-promiseall">（6）手写 Promise.all</a></li>
    <li><a href="#7手写并发">（7）手写并发</a></li>
    <li><a href="#8promise讲解all和race的作用">（8）promise讲解，all和race的作用</a></li>
    <li><a href="#9promise输出">（9）promise输出</a></li>
    <li><a href="#10迭代器的yield-和-yield的区别还有promise的race">（10）迭代器的，yield 和 yield*的区别。还有promise的race。</a></li>
    <li><a href="#11promise的日常应用">（11）promise的日常应用</a></li>
    <li><a href="#12简单描述一下promise并说明如何在外部进行resolve">（12）简单描述一下promise，并说明如何在外部进行resolve()</a></li>
    <li><a href="#13promise的作用及用法以及内部实现原理">（13）Promise的作用及用法以及内部实现原理？</a></li>
    <li><a href="#14说一下你对-generator-的了解">（14）说一下你对 generator 的了解？</a></li>
    <li><a href="#15promisethenthen-promisecatchthen-ok-不">（15）promise.then().then() ，promise.catch().then() ok 不？</a></li>
    <li><a href="#16js实现带并发限制的调度器其实就是使用promise限制并发">（16）js实现带并发限制的调度器，其实就是使用promise限制并发</a></li>
    <li><a href="#17如何理解-promisepromise-对象的含义">（17）如何理解 Promise？Promise 对象的含义？</a></li>
    <li><a href="#18对async和await的理解">（18）对async和await的理解</a></li>
    <li><a href="#19vue-promise原理">（19）vue promise原理</a></li>
    <li><a href="#20vue-promise-同时发起">（20）vue promise 同时发起</a></li>
    <li><a href="#21js-并发请求">（21）js 并发请求</a></li>
    <li><a href="#22如何破坏promise链">（22）如何破坏promise链？</a></li>
    <li><a href="#23catch-之后的-then-还会执行吗">（23）catch 之后的 then 还会执行吗？</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <blockquote>
<p>前言：个人学习笔记，初识Promise</p>
</blockquote>
<h1 id="1promise解决了什么问题">1.Promise解决了什么问题？</h1>
<p>用来解决 <strong>回调地狱</strong> 问题</p>
<p>回调地狱：在JS中，为了实现某些逻辑经常会写出层层嵌套的 <strong>回调函数</strong>，如果嵌套过多，会极大的影响代码可读性和逻辑，这种情况被称为回调地狱。比如说把一个函数A作为回调函数，但是该函数又接收一个函数B作为参数，甚至B还能接受函数C作为参数，这样层层嵌套，人们称为<strong>回调地狱</strong>，代码阅读性非常的差。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">        let sayHello = function (name, callback) {
            setTimeout(function () {
                console.log(name);
                callback();
            }, 1000);
        }
        sayHello(&#39;first&#39;, function () {
            sayHello(&#39;second&#39;, function () {
                sayHello(&#39;third&#39;, function () {
                    console.log(&#39;end&#39;);
                });
            });
        })
</code></pre></td></tr></table>
</div>
</div><p>回调函数：回调是一个函数，它作为参数传递给另一个函数，并在其父函数完成后执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">        function doSomething(msg, callback) {
            alert(msg);
            if (typeof callback === &#39;function&#39;) {
                callback();
            }
        }
        doSomething(&#39;回调函数&#39;, function () {
            alert(&#39;匿名函数实现回调&#39;);
        });
</code></pre></td></tr></table>
</div>
</div><p>回调既可以同步回调，也可以异步回调。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">        // 同步回调
        function getNodes(param, callback) {
            let list = JSON.stringify(param);
            if (typeof callback === &#39;function&#39;) {
                callback(list)
            }
        }
        getNodes(&#39;[1,2,3]&#39;, function (nodes) {
            console.log(nodes);
        });
        //ajax回调
        $.get(&#39;ajax/test.html&#39;, function (data) {
            $(&#39;box&#39;).html(data);
        })

        // 点击事件回调 
        $(&#39;#myBtn&#39;).click(function () {
            alert(&#39;click myBtn!&#39;);
        })
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>感受：JS虽然灵活，但是灵活的同时，带来的缺点就是，写代码的过程中需要加一些判断，比如上面这段代码中判断callback是不是函数，在别的强类型语言中，这个callback如果不是函数，可能写的时候编辑器就会直接提醒，传入参数的类型不对。所以就会出现TypeScript。</p>
</blockquote>
<p>注意回调函数中的this指向：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">        var clientData = {
            id: 096545,
            fullName: &#34;Not Set&#34;,
            setUserName: function (firstName, lastName) {
                this.fullName = firstName + &#34; &#34; + lastName;
            }
        }
        function getUserInput(firstName, lastName, callback) {
            //调用回调函数存储，此时是window调用的这个传进来的函数
            callback(firstName, lastName);
        }
        getUserInput(&#34;Barack&#34;, &#34;Obama&#34;, clientData.setUserName);
        console.log(clientData.fullName);  //Not Set
        console.log(window.fullName);  //Barack Obama
</code></pre></td></tr></table>
</div>
</div><p>上面这段代码中回调函数的this是指向window的，此时可以使用call或apply改下this的指向</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">        var clientData = {
            id: 096545,
            fullName: &#34;Not Set&#34;,
            setUserName: function (firstName, lastName) {
                this.fullName = firstName + &#34; &#34; + lastName;
            }
        }
        function getUserInput(firstName, lastName, callback) {
            //调用回调函数存储，此时是window调用的这个传进来的函数
            callback.call(clientData, firstName, lastName);
        }
        getUserInput(&#34;Barack&#34;, &#34;Obama&#34;, clientData.setUserName);
        console.log(clientData.fullName);  //Barack Obama
        console.log(window.fullName);  //undefined
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>问题：JS底层是怎么实现异步的，相关内容：V8引擎是如何实现异步的，EventLoop相关原理深度解析,JS执行过程中的堆栈变化，异步是不是等同于并行以及其它相关底层问题。</p>
</blockquote>
<p>链式调用：同一对象多次其属性或方法的时候，我们需要多次书写对象进行“.” 或 () 操作；链式调用是一种简化此过程的一种编码方式，使代码简洁、易读。</p>
<p>函数柯里化：</p>
<h1 id="2promise使用">2.Promise使用</h1>
<p>资料相关：</p>
<ul>
<li>1.<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">使用 Promise</a></li>
<li>2.<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a></li>
</ul>
<p>Promise是一个对象，代表一个异步操作的最终完结或失败。</p>
<h2 id="1promise特点">（1）Promise特点</h2>
<p>1.在本轮 事件循环 运行完成之前，回调函数是不会被调用的。</p>
<p>2.即使异步操作已经完成（成功或失败），在这之后通过 then() 添加的回调函数也会被调用。</p>
<p>3.通过多次调用 then() 可以添加多个回调函数，它们会按照插入顺序进行执行。</p>
<p>4.Promise 很棒的一点就是链式调用（chaining）（Promise可以是使用链式调用）</p>
<h2 id="2链式调用">（2）链式调用</h2>
<p>连续执行两个或者多个异步操作是一个常见的需求，在上一个操作执行成功之后，开始下一个的操作，并带着上一步操作所返回的结果。我们可以通过创造一个 Promise 链来实现这种需求。基本上，每一个 Promise 都代表了链中另一个异步过程的完成。</p>
<blockquote>
<p>注意：一定要有返回值，否则，callback 将无法获取上一个 Promise 的结果。(如果使用箭头函数，() =&gt; x 比 () =&gt; { return x; } 更简洁一些，但后一种保留 return 的写法才支持使用多个语句。）。</p>
</blockquote>
<h2 id="3catch-的后续链式操作">(3)Catch 的后续链式操作</h2>
<p>有可能会在一个回调失败之后继续使用链式操作，即，使用一个 catch，这对于在链式操作中抛出一个失败之后，再次进行新的操作会很有用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript">        <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;初始化&#39;</span><span class="p">);</span>

            <span class="nx">resolve</span><span class="p">();</span>
        <span class="p">})</span>
            <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;有哪里不对了&#39;</span><span class="p">);</span>

                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;执行「这个」”&#39;</span><span class="p">);</span>
            <span class="p">})</span>
            <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;执行「那个」&#39;</span><span class="p">);</span>
            <span class="p">})</span>
            <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;执行「这个」，无论前面发生了什么&#39;</span><span class="p">);</span>
            <span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>打印结果：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4cc42c8fb93435aa1093e628e760435~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<blockquote>
<p>注意：因为抛出了错误 有哪里不对了，所以前一个 执行「这个」 没有被输出。</p>
</blockquote>
<h2 id="4错误传递">（4）错误传递</h2>
<p>通常，一遇到异常抛出，浏览器就会顺着 Promise 链寻找下一个 onRejected 失败回调函数或者由 .catch() 指定的回调函数。这和以下同步代码的工作原理（执行过程）非常相似。</p>
<blockquote>
<p>通过捕获所有的错误，甚至抛出异常和程序错误，Promise 解决了回调地狱的基本缺陷。这对于构建异步操作的基础功能而言是很有必要的。</p>
</blockquote>
<h2 id="5promise-拒绝事件">（5）Promise 拒绝事件</h2>
<p>当 <strong>Promise</strong> 被拒绝时，会有下文所述的两个事件之一被派发到<strong>全局作用域</strong>（通常而言，就是window；如果是在 web worker 中使用的话，就是 Worker 或者其他 worker-based 接口）。</p>
<h3 id="1rejectionhandled">（1）rejectionhandled</h3>
<p>当 Promise 被拒绝、并且在 reject 函数处理该 rejection 之后会派发此事件。</p>
<h3 id="2unhandledrejection">（2）unhandledrejection</h3>
<p>当 Promise 被拒绝，但没有提供 reject 函数来处理该 rejection 时，会派发此事件。</p>
<p>以上两种情况中，PromiseRejectionEvent 事件都有两个属性，一个是 promise 属性，该属性指向被驳回的 Promise，另一个是 reason 属性，该属性用来说明 Promise 被驳回的原因。</p>
<p>因此，我们可以通过以上事件为 Promise 失败时提供补偿处理，也有利于调试 Promise 相关的问题。在每一个上下文中，该处理都是全局的，因此不管源码如何，所有的错误都会在同一个处理函数中被捕捉并处理。</p>
<p>一个特别有用的例子：当你使用 Node.js 时，有些依赖模块可能会有未被处理的 rejected promises，这些都会在运行时打印到控制台。你可以在自己的代码中捕捉这些信息，然后添加与 unhandledrejection 相应的处理函数来做分析和处理，或只是为了让你的输出更整洁。举例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&#34;unhandledrejection&#34;</span><span class="p">,</span> <span class="nx">event</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* 你可以在这里添加一些代码，以便检查
</span><span class="cm">     event.promise 中的 promise 和
</span><span class="cm">     event.reason 中的 rejection 原因 */</span>

  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>调用 event 的 preventDefault() 方法是为了告诉 JavaScript 引擎当 Promise 被拒绝时不要执行默认操作，默认操作一般会包含把错误打印到控制台，Node 就是如此的。</p>
<p>理想情况下，在忽略这些事件之前，我们应该检查所有被拒绝的 Promise，来确认这不是代码中的 bug。</p>
<h2 id="6在旧式回调-api-中创建-promise">（6）在旧式回调 API 中创建 Promise</h2>
<p>理想状态下，所有的异步函数都已经返回 Promise 了。但有一些 API 仍然使用旧方式来传入的成功（或者失败）的回调。典型的例子就是 setTimeout() 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">saySomething</span><span class="p">(</span><span class="s2">&#34;10 seconds passed&#34;</span><span class="p">),</span> <span class="mi">10000</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>混用旧式回调和 Promise 可能会造成运行时序问题。如果 saySomething 函数失败了，或者包含了编程错误，那就没有办法捕获它了。这得怪 setTimeout。</p>
<p>幸运地是，我们可以用 Promise 来封装它。最好的做法是，将这些有问题的函数封装起来，留在底层，并且永远不要再直接调用它们：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kr">const</span> <span class="nx">wait</span> <span class="o">=</span> <span class="nx">ms</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">ms</span><span class="p">));</span>

<span class="nx">wait</span><span class="p">(</span><span class="mi">10000</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">saySomething</span><span class="p">(</span><span class="s2">&#34;10 seconds&#34;</span><span class="p">)).</span><span class="k">catch</span><span class="p">(</span><span class="nx">failureCallback</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>通常，Promise 的构造器接收一个执行函数(executor)，我们可以在这个执行函数里手动地 resolve 和 reject 一个 Promise。既然 setTimeout 并不会真的执行失败，那么我们可以在这种情况下忽略 reject。</p>
<h2 id="7组合">（7）组合</h2>
<p>Promise.resolve() 和 Promise.reject() 是手动创建一个已经 resolve 或者 reject 的 Promise 快捷方法。它们有时很有用。</p>
<p>Promise.all() 和 Promise.race() 是并行运行异步操作的两个组合式工具。</p>
<p>我们可以发起并行操作，然后等多个操作全部结束后进行下一步操作，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">func1</span><span class="p">(),</span> <span class="nx">func2</span><span class="p">(),</span> <span class="nx">func3</span><span class="p">()])</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(([</span><span class="nx">result1</span><span class="p">,</span> <span class="nx">result2</span><span class="p">,</span> <span class="nx">result3</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="cm">/* use result1, result2 and result3 */</span> <span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>可以使用一些聪明的 JavaScript 写法实现时序组合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="p">[</span><span class="nx">func1</span><span class="p">,</span> <span class="nx">func2</span><span class="p">,</span> <span class="nx">func3</span><span class="p">].</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">p</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">f</span><span class="p">),</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">())</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result3</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="cm">/* use result3 */</span> <span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>通常，我们递归调用一个由异步函数组成的数组时，相当于一个 Promise 链：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">func1</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">func2</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">func3</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>我们也可以写成可复用的函数形式，这在函数式编程中极为普遍：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kr">const</span> <span class="nx">applyAsync</span> <span class="o">=</span> <span class="p">(</span><span class="nx">acc</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">acc</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">composeAsync</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">funcs</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">funcs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">applyAsync</span><span class="p">,</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><p>composeAsync() 函数将会接受任意数量的函数作为其参数，并返回一个新的函数，该函数接受一个通过 composition pipeline 传入的初始值。这对我们来说非常有益，因为任一函数可以是异步或同步的，它们能被保证按顺序执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kr">const</span> <span class="nx">transformData</span> <span class="o">=</span> <span class="nx">composeAsync</span><span class="p">(</span><span class="nx">func1</span><span class="p">,</span> <span class="nx">func2</span><span class="p">,</span> <span class="nx">func3</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">result3</span> <span class="o">=</span> <span class="nx">transformData</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>在 ECMAScript 2017 标准中, 时序组合可以通过使用 async/await 而变得更简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">let</span> <span class="nx">result</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">f</span> <span class="k">of</span> <span class="p">[</span><span class="nx">func1</span><span class="p">,</span> <span class="nx">func2</span><span class="p">,</span> <span class="nx">func3</span><span class="p">])</span> <span class="p">{</span>
  <span class="nx">result</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">f</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="8时序">8.时序</h2>
<p>为了避免意外，即使是一个已经变成 resolve 状态的 Promise，传递给 then() 的函数也总是会被异步调用。</p>
<h2 id="9嵌套">9.嵌套</h2>
<p>简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise，因为嵌套经常会是粗心导致的。可查阅下一节的常见错误中的例子。</p>
<h2 id="10常见错误">10.常见错误</h2>
<p>在编写 Promise 链时，需要注意以下示例中展示的几个错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="c1">// 错误示例，包含 3 个问题！
</span><span class="c1"></span>
<span class="nx">doSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">doSomethingElse</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="c1">// 没有返回 Promise 以及没有必要的嵌套 Promise
</span><span class="c1"></span>  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">newResult</span> <span class="p">=&gt;</span> <span class="nx">doThirdThing</span><span class="p">(</span><span class="nx">newResult</span><span class="p">));</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">doFourthThing</span><span class="p">());</span>
<span class="c1">// 最后，是没有使用 catch 终止 Promise 调用链，可能导致没有捕获的异常
</span></code></pre></td></tr></table>
</div>
</div><p>一个好的经验法则是总是返回或终止 Promise 链，并且一旦你得到一个新的 Promise，返回它。下面是修改后的平面化的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nx">doSomething</span><span class="p">()</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">doSomethingElse</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">newResult</span> <span class="p">=&gt;</span> <span class="nx">doThirdThing</span><span class="p">(</span><span class="nx">newResult</span><span class="p">))</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">doFourthThing</span><span class="p">())</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>使用 async/await 可以解决以上大多数错误，使用 async/await 时，最常见的语法错误就是忘记了 await 关键字。</p>
</blockquote>
<h1 id="3promise">3.Promise</h1>
<p>一个Promise对象在被创建出来的时候，不一定值是什么，异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。</p>
<h2 id="1promise状态">（1）Promise状态</h2>
<p>1.待定（pending）：初始状态，既没有兑现，也没有拒绝。
2.已兑现（fulfilled）：意味着操作成功完成。
3.已拒绝（rejected）：意味着操作失败。</p>
<p>因为 Promise.prototype.then 和  Promise.prototype.catch 方法返回的是 promise， 所以它们可以被链式调用。</p>
<p>resolved：
已决议（resolved），它表示 promise 已经处于已敲定(settled)状态，或者为了匹配另一个 promise 的状态被&quot;锁定&quot;了。</p>
<blockquote>
<p>注意：resolved不在Promise的三种状态之中</p>
</blockquote>
<h2 id="2promise构造函数">（2）Promise()构造函数</h2>
<p>用于包装还没有添加 promise 支持的函数。</p>
<h1 id="4promise方法">4.Promise方法</h1>
<h2 id="1promiseall">（1）Promise.all()</h2>
<p>只有当参数里的所有异步操作都返回成功的时候，Promise.all()才会返回成功，否则，有一个错误，就会返回错误。</p>
<p>语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">iterable</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>参数：</p>
<p>一个可迭代对象，如 Array 或 String。</p>
<p>返回值：</p>
<p>1.传入空的可迭代对象时，返回一个已完成状态的Promise</p>
<p>2.传入的参数不包含Promise，返回一个异步完成的Promise</p>
<p>3.其它情况下返回一个处理中（pending）的Promise</p>
<p>使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript">        <span class="kd">var</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="mi">1337</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">);</span>
        <span class="p">});</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p3</span><span class="p">,</span> <span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">]).</span><span class="nx">then</span><span class="p">(</span><span class="nx">values</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">values</span><span class="p">);</span> <span class="c1">// [3, 1337, &#34;foo&#34;]
</span><span class="c1"></span>        <span class="p">}));</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript">        <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
        <span class="kd">var</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">444</span><span class="p">)]);</span>
        <span class="kd">var</span> <span class="nx">p3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="mi">555</span><span class="p">)]);</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p2</span><span class="p">);</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p3</span><span class="p">);</span>
        <span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2promiseallsettled">（2）Promise.allSettled()</h2>
<p>该Promise.allSettled()方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p>
<p>当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个promise的结果时，通常使用它。</p>
<p>参数：</p>
<p>一个可迭代的对象，例如Array，其中每个成员都是Promise。</p>
<blockquote>
<p>注意：此方法需要谷歌76版本以上才会支持</p>
</blockquote>
<h2 id="3promiseany">（3）Promise.any()</h2>
<p>只要Promise中有一个返回成功就返回成功，所有的都失败才会返回失败，跟 Promise.all()方法正好相反， any 方法和 all 方法有点类似于或和且的关系。</p>
<blockquote>
<p>此方法需要谷歌85版本以上才会支持</p>
</blockquote>
<h2 id="4promiserace">（4）Promise.race()</h2>
<p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p>
<p>只要可迭代对象中有一个返回，Promise.race()就会立马返回这个状态的值，返回的也是一个Promise</p>
<h2 id="5promisereject">（5）Promise.reject()</h2>
<p>Promise.reject()方法返回一个带有拒绝原因的Promise对象。</p>
<p>参数：</p>
<p>reason：表示Promise被拒绝的原因。</p>
<p>返回值：一个给定原因了的被拒绝的 Promise。</p>
<h2 id="6promiseresolve">（6）Promise.resolve()</h2>
<p>Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。</p>
<blockquote>
<p>警告：不要在解析为自身的thenable 上调用Promise.resolve。这将导致无限递归，因为它试图展平无限嵌套的promise。一个例子是将它与Angular中的异步管道一起使用。在此处了解更多信息。</p>
</blockquote>
<p>参数:</p>
<p>value：将被Promise对象解析的参数，也可以是一个Promise对象，或者是一个thenable。</p>
<p>返回值：</p>
<p>返回一个带着给定值解析过的Promise对象，如果参数本身就是一个Promise对象，则直接返回这个Promise对象。</p>
<h1 id="5promise原型">5.Promise原型</h1>
<h2 id="1promiseprototypecatch">（1）Promise.prototype.catch()</h2>
<p>添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果。返回一个Promise，所以catch后面可以继续使用then。</p>
<h2 id="2promiseprototypethen">（2）Promise.prototype.then()</h2>
<p>添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve.</p>
<p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p>
<h2 id="3promiseprototypefinally">（3）Promise.prototype.finally()</h2>
<p>finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在Promise是否成功完成后都需要执行的代码提供了一种方式。
这避免了同样的语句需要在then()和catch()中各写一次的情况。</p>
<p>返回值：</p>
<p>返回一个设置了 finally 回调函数的Promise对象。</p>
<h1 id="6创建promise">6.创建Promise</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kr">const</span> <span class="nx">myFirstPromise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ?做一些异步操作，最终会调用下面两者之一:
</span><span class="c1"></span>  <span class="c1">//
</span><span class="c1"></span>  <span class="c1">//   resolve(someValue); // fulfilled
</span><span class="c1"></span>  <span class="c1">// ?或
</span><span class="c1"></span>  <span class="c1">//   reject(&#34;failure reason&#34;); // rejected
</span><span class="c1"></span><span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="7asyncawait">7.async/await</h1>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">async函数</a></p>
<p>async/await时ES8新增的</p>
<h1 id="8generator-和-yield">8.generator 和 yield</h1>
<h1 id="9trycatch">9.try&hellip;catch</h1>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch">try&hellip;catch</a></p>
<h1 id="3涉及到的面试题">3.涉及到的面试题</h1>
<h2 id="1promisethen里抛出的错误能否被trycatch捕获为什么">（1）Promise.then里抛出的错误能否被try&hellip;catch捕获，为什么？</h2>
<!-- raw HTML omitted -->
<p>不能，因为try catch只能处理同步的错误，对异步错误没有办法捕获</p>
<p>try catch为什么不能捕获异步错误？</p>
<p>因为try执行时从上到下的，异步代码没有返回，try&hellip;catch 怎么捕获</p>
<p>then 的第二个参数和使用 catch 的区别</p>
<p>主要区别就是，如果在 then 的第一个函数里抛出了异常，后面的 catch 能捕获到，而第二个函数捕获不到</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript">        <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="p">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">123</span><span class="p">))</span>
            <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">()</span>
            <span class="p">},</span> <span class="nx">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
            <span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">458</span><span class="p">);</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
            <span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>也就是说 then 里面抛出的还是需要后面的catch去捕获，而then的第二个参数回调函数是在之前返回的结果为 rejected 时调用的</p>
</blockquote>
<p>那 then 之后的错误如何捕获呢。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">function</span> <span class="nx">main3</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;then&#39;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">e</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>只能是在回调函数内部 catch 错误，并把错误信息返回，error 会传递到下一个 then 的回调。</p>
<blockquote>
<p>拓展：promise 内部的错误不会冒泡出来，而是被 promise 吃掉了，只有通过 promise.catch 才可以捕获，所以用 Promise 一定要写 catch 啊。</p>
</blockquote>
<!-- raw HTML omitted -->
<h2 id="2你怎么解决回掉地狱的问题你对proxy和promise的理解在哪里用到过">（2）你怎么解决“回掉地狱”的问题？你对Proxy，和Promise的理解，在哪里用到过？</h2>
<h2 id="3请手写实现一个-promise">（3）请手写实现一个 promise？</h2>
<h2 id="4淘宝等网站的倒计时功能如何实现">（4）淘宝等网站的倒计时功能如何实现？</h2>
<h2 id="5写一个-promise-重试函数可以设置时间间隔和次数">（5）写一个 promise 重试函数，可以设置时间间隔和次数</h2>
<h2 id="6手写-promiseall">（6）手写 Promise.all</h2>
<h2 id="7手写并发">（7）手写并发</h2>
<h2 id="8promise讲解all和race的作用">（8）promise讲解，all和race的作用</h2>
<h2 id="9promise输出">（9）promise输出</h2>
<h2 id="10迭代器的yield-和-yield的区别还有promise的race">（10）迭代器的，yield 和 yield*的区别。还有promise的race。</h2>
<h2 id="11promise的日常应用">（11）promise的日常应用</h2>
<h2 id="12简单描述一下promise并说明如何在外部进行resolve">（12）简单描述一下promise，并说明如何在外部进行resolve()</h2>
<h2 id="13promise的作用及用法以及内部实现原理">（13）Promise的作用及用法以及内部实现原理？</h2>
<h2 id="14说一下你对-generator-的了解">（14）说一下你对 generator 的了解？</h2>
<h2 id="15promisethenthen-promisecatchthen-ok-不">（15）promise.then().then() ，promise.catch().then() ok 不？</h2>
<h2 id="16js实现带并发限制的调度器其实就是使用promise限制并发">（16）js实现带并发限制的调度器，其实就是使用promise限制并发</h2>
<h2 id="17如何理解-promisepromise-对象的含义">（17）如何理解 Promise？Promise 对象的含义？</h2>
<h2 id="18对async和await的理解">（18）对async和await的理解</h2>
<h2 id="19vue-promise原理">（19）vue promise原理</h2>
<h2 id="20vue-promise-同时发起">（20）vue promise 同时发起</h2>
<h2 id="21js-并发请求">（21）js 并发请求</h2>
<h2 id="22如何破坏promise链">（22）如何破坏promise链？</h2>
<h2 id="23catch-之后的-then-还会执行吗">（23）catch 之后的 then 还会执行吗？</h2>
<p>会继续执行，因为catch方法返回的是promise，所以后续的then还会继续执行，当然如果在catch中手动返回 Promise.reject()，那后续的then就不会被调用了。</p>

    </div>

    
    


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://xkhm.net/tags/javascript/">JavaScript</a>
          <a href="https://xkhm.net/tags/promise/">Promise</a>
          <a href="https://xkhm.net/tags/%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/">异步回调</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/css%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80%E4%B9%8Bflex/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default" style="position: relative;top: -2px;">CSS弹性盒子布局之Flex</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%89%8B%E5%86%99bind/">
            <span class="next-text nav-default" style="position: relative;top: -3px;">JS基础之手写bind</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  















        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="im.xkhm@gmail.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/yukiyukixing" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://www.zhihu.com/people/yuki-42-63" rel="me noopener" class="iconfont"
      title="zhihu"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M351.791182 562.469462l192.945407 0c0-45.367257-21.3871-71.939449-21.3871-71.939449L355.897709 490.530013c3.977591-82.182744 7.541767-187.659007 8.816806-226.835262l159.282726 0c0 0-0.86367-67.402109-18.578124-67.402109s-279.979646 0-279.979646 0 16.850783-88.141456 39.318494-127.053698c0 0-83.60514-4.510734-112.121614 106.962104S81.344656 355.077018 76.80834 367.390461c-4.536316 12.313443 24.62791 5.832845 36.941354 0 12.313443-5.832845 68.050885-25.924439 84.252893-103.69571l86.570681 0c1.165546 49.28652 4.596691 200.335724 3.515057 226.835262L109.86113 490.530013c-25.275663 18.147312-33.701566 71.939449-33.701566 71.939449L279.868105 562.469462c-8.497535 56.255235-23.417339 128.763642-44.275389 167.210279-33.05279 60.921511-50.55235 116.65793-169.802314 212.576513 0 0-19.442818 14.257725 40.829917 9.073656 60.273758-5.185093 117.305683-20.739347 156.840094-99.807147 20.553105-41.107233 41.805128-93.250824 58.386782-146.138358l-0.055259 0.185218 167.855986 193.263655c0 0 22.035876-51.847855 5.832845-108.880803L371.045711 650.610918l-42.1244 31.157627-0.045025 0.151449c11.69946-41.020252 20.11206-81.5749 22.726607-116.858498C351.665315 564.212152 351.72876 563.345412 351.791182 562.469462z"></path>
  <path d="M584.918753 182.033893l0 668.840094 70.318532 0 28.807093 80.512708 121.875768-80.512708 153.600307 0L959.520453 182.033893 584.918753 182.033893zM887.150192 778.934538l-79.837326 0-99.578949 65.782216-23.537066-65.782216-24.855084 0L659.341766 256.673847l227.807403 0L887.149169 778.934538z"></path>
</svg>

    </a>


<a href="https://xkhm.net/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
  
</div>

<div class="copyright">
  
  
  <span class="copyright-year">
    &copy;
    
    2019 -
    2023
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
      星空海绵
      
    </span></span>
  
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//changkun.de/urlstat/client.js"></script>












</body>
</html>
