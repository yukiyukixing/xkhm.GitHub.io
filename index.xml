<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>星空海绵 - 星空浩瀚 | 海绵吸水</title>
    <link>https://xkhm.net/</link>
    <description>Recent content on 星空海绵 - 星空浩瀚 | 海绵吸水</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>星空海绵</copyright>
    <lastBuildDate>Fri, 25 Dec 2020 08:24:35 +0800</lastBuildDate>
    
        <atom:link href="https://xkhm.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>生活</title>
      <link>https://xkhm.net/life/</link>
      <pubDate>Sat, 19 Dec 2020 22:14:17 +0800</pubDate>
      
      <guid>https://xkhm.net/life/</guid>
      
        <description>&lt;h1 id=&#34;页面结构待完善&#34;&gt;页面结构待完善&lt;/h1&gt;
&lt;p&gt;待完善&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>技术</title>
      <link>https://xkhm.net/technology/</link>
      <pubDate>Sat, 19 Dec 2020 22:19:35 +0800</pubDate>
      
      <guid>https://xkhm.net/technology/</guid>
      
        <description>&lt;h1 id=&#34;页面结构待完善&#34;&gt;页面结构待完善&lt;/h1&gt;
&lt;p&gt;待完善&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>随笔</title>
      <link>https://xkhm.net/essay/</link>
      <pubDate>Sat, 19 Dec 2020 22:17:09 +0800</pubDate>
      
      <guid>https://xkhm.net/essay/</guid>
      
        <description>&lt;h1 id=&#34;页面结构待完善&#34;&gt;页面结构待完善&lt;/h1&gt;
&lt;p&gt;待完善&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>待做</title>
      <link>https://xkhm.net/tobedone/</link>
      <pubDate>Sat, 19 Dec 2020 22:19:35 +0800</pubDate>
      
      <guid>https://xkhm.net/tobedone/</guid>
      
        <description>&lt;h1 id=&#34;页面结构待完善&#34;&gt;页面结构待完善&lt;/h1&gt;
&lt;p&gt;待完善&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>关于</title>
      <link>https://xkhm.net/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://xkhm.net/about/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;一只小透明的前端开发（待补充）&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>JS基础之手写bind</title>
      <link>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%89%8B%E5%86%99bind/</link>
      <pubDate>Fri, 25 Dec 2020 08:24:35 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%89%8B%E5%86%99bind/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;文章类型：学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1bind的使用&#34;&gt;1.bind()的使用&lt;/h1&gt;
&lt;p&gt;😏😏😏😏😏&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(name, job) {
            console.log(name);
            console.log(job);
            console.log(this.age);
        }
        getInfo.bind(obj, &#39;星空海绵&#39;)(&#39;Software Engineer&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;bind在第一个参数之后的参数，可以直接从bind()传,也可以从bind()返回的函数上传，如上代码。&lt;/p&gt;
&lt;h1 id=&#34;2bind参数&#34;&gt;2.bind()参数&lt;/h1&gt;
&lt;p&gt;🤔🤔🤔🤔🤔&lt;/p&gt;
&lt;h2 id=&#34;1thisarg&#34;&gt;（1）thisArg&lt;/h2&gt;
&lt;p&gt;bind的第一个参数是bind被函数调用时作为this参数传给调用函数。如果bind()参数列表为空，或者thisArg为null或undefined,执行作用域的this就是新函数的this。如果使用new操作符操作绑定函数，则会忽略这个thisArg参数。当使用bind在setTimeout中创建一个函数时，作为thisArg传递的任何原始值都会被转换为object。-&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&#34;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.bind的第一个参数是bind被函数调用时作为this参数传给调用函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo() {
            console.log(this); // {age: 18}
        }
        getInfo.bind(obj)();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时调用函数 getInfo 中的 this 就是 bind() 中传入的 obj&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.bind()参数列表为空，或者thisArg为null或undefined,执行作用域的this就是新函数的this&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo() {
            console.log(this); // Window {}
        }
        getInfo.bind()();
        getInfo.bind(null)();
        getInfo.bind(undefined)();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时bind的参数为 空 或 null 或 undefined，因为实际上 getInfo 是全局对象调用的，在这里也就是 window 对象，所以此时this就是指向 window 对象的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;3.如果使用new操作符操作绑定函数，则会忽略这个thisArg参数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo() {
            console.log(this); // getInfo {}
        }
        let a = getInfo.bind(obj)
        let b = new a();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时不管调用的时候传不传参数 obj，getInfo 中的 this 都是指向创建对象 b 的，这里就涉及到 new 构造函数创建对象的过程了，建议精读 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&#34;&gt;MDN&lt;/a&gt; 这部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4.当使用bind在setTimeout中创建一个函数时，作为thisArg传递的任何原始值都会被转换为object。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        function A() {
            this.name = &#39;星空海绵&#39;;
        }
        A.prototype.say = function () {
            setTimeout(this.read.bind(this), 1000)
        }
        A.prototype.read = function () {
            console.log(this.name);
        }
        let b = new A();
        b.say();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在默认情况下，使用 setTimeout() 时，this 关键字会指向 window （或 global）对象。当类的方法中需要 this 指向类的实例时，你可能需要显式地把 this 绑定到回调函数，就不会丢失该实例的引用。&lt;/p&gt;
&lt;h2 id=&#34;2arg1-arg2-&#34;&gt;（2）arg1, arg2, &amp;hellip;&lt;/h2&gt;
&lt;p&gt;当bind被函数调用时，传给调用函数的参数列表&lt;/p&gt;
&lt;h1 id=&#34;3手写-bind&#34;&gt;3.手写 bind()&lt;/h1&gt;
&lt;p&gt;😎😎😎😎😎&lt;/p&gt;
&lt;h2 id=&#34;1不支持-new-调用-bind-返回的函数&#34;&gt;(1)不支持 new 调用 bind() 返回的函数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 18
        }
        function getInfo(name, job) {
            this.a = 100;
            console.log(name); // 星空海绵
            console.log(job); // Software Engineer
            console.log(this.age); // undefined
        }
        Function.prototype.myBind = function () {
            if(typeof this !== &#39;function&#39;){
            	throw new TypeError(&#39;调用者必须是函数&#39;)
            }
            var _that = this,
                arg = arguments[0],
                slice = Array.prototype.slice,
                args = slice.call(arguments, 1);
            return function () {
                return _that.apply(arg, args.concat(slice.call(arguments)))
            }
        }

        var a = getInfo.myBind(obj, &#39;星空海绵&#39;);
        var b = new a(&#39;Software Engineer&#39;);
        console.log(b); // {}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的代码中我们可以看出来，此时当使用 new 调用时，并不会忽略掉传入的第一个参数 obj，调用函数的 this 一直是传入的第一个参数，不符合上面列举的原生的 bind() 第一个参数的第3条，当使用 new 调用时，会忽略第一个参数&lt;/p&gt;
&lt;h2 id=&#34;2支持-new-调用&#34;&gt;(2)支持 new 调用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 18
        }
        function getInfo(name, job) {
            this.a = 100;
            console.log(name);
            console.log(job);
            console.log(this.age);
        }
        Function.prototype.myBind = function () {
            if (typeof this !== &#39;function&#39;) {
                throw new TypeError(&#39;调用者必须是函数&#39;)
            }
            var _that = this,
                arg = arguments[0],
                slice = Array.prototype.slice,
                args = slice.call(arguments, 1),
                fn = function () { },
                fn2 = function () {
                    if (fn.prototype.isPrototypeOf(this)) {
                        return _that.apply(this, args.concat(slice.call(arguments)))
                    } else {
                        return _that.apply(arg, args.concat(slice.call(arguments)))
                    }
                };
            if (this.prototype) {
                fn.prototype = this.prototype;
            }
            fn2.prototype = new fn();
            return fn2;
        }

        var a = getInfo.myBind(obj, &#39;星空海绵&#39;),
            b = new a(&#39;Software Engineer&#39;);
        console.log(b); // {a: 100}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Vue从入门到出门</title>
      <link>https://xkhm.net/post/vue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%87%BA%E9%97%A8/</link>
      <pubDate>Thu, 24 Dec 2020 22:16:35 +0800</pubDate>
      
      <guid>https://xkhm.net/post/vue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%87%BA%E9%97%A8/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;前言：人家都开始上vue3.0了，我还在重学vue2.0，啊这🤡🤡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提醒：个人学习笔记，适合随手翻阅，精读需考量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1手摸手左手摸右手搭建一个vue的工程基于vue20&#34;&gt;1.手摸手（左手摸右手）搭建一个vue的工程，基于vue2.0&lt;/h1&gt;
&lt;p&gt;🔞🔞🔞🔞🔞&lt;/p&gt;
&lt;h2 id=&#34;1新建一个文件夹&#34;&gt;（1）新建一个文件夹😀😀&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d1cf5ccba04913bf4b636809d5ee02~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2执行-npm-install--g-vuecli-命令&#34;&gt;（2）执行 npm install -g @vue/cli 命令😋😋&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6c5d35990e94341894ebacb68f96d9c~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3执行-vue-create-vue-demo-命令&#34;&gt;（3）执行 vue create vue-demo 命令😥😥&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7921d90abba4179b73a61dcc1e30d36~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;
报错了，只需要去 D:\0.node\node_global\vue.ps1 图上报错的这个文件夹中将 vue.ps1 文件删掉再次运行这个命令即可&lt;/p&gt;
&lt;p&gt;项目搭建成功
&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91ca1f4024d1461a8337cde50ebdf42b~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;搭建成功😄😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2helloworld&#34;&gt;2.Hello,world!&lt;/h1&gt;
&lt;p&gt;🤔🤔🤔🤔🤔&lt;/p&gt;
&lt;h2 id=&#34;1运行-cd-vue-demo-和-npm-run-serve-&#34;&gt;（1）运行 cd vue-demo 和 npm run serve 😎😎&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1966c4de059444cbd86605ad086e724~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时，按住 ctrl+鼠标点击链接 就可以访问 vue 工程启动起来的页面了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb3b9a4cdc6547e381f60da95f2e10f7~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;页面上没有 Hello,world! 差评😠😠&lt;/p&gt;
&lt;h2 id=&#34;2自己写-helloworld-&#34;&gt;（2）自己写 Hello,world! 🤒🤒&lt;/h2&gt;
&lt;p&gt;修改HelloWorld文件：
&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f3840da6a84444195bc601d43cb4652~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;
修改路由文件：
&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7014f9bf75db4cdb80ccc8d5dcc21757~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;
Hello,world!
&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dfa2ada45a846d7bbf53edb9b01a7a9~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;好了，vue 算是已经进入了解的范围了，写过HelloWorld了，学任何一门语言不写个 Hello,world! 是不完整的，傲娇的野生程序员😒😒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;成就达成：了解Vue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;3开始照猫画虎之-cv-大法&#34;&gt;3.开始照猫画虎之 CV 大法&lt;/h1&gt;
&lt;p&gt;🤗🤗🤗🤗🤗&lt;/p&gt;
&lt;h2 id=&#34;1在-compoents-下新建一个-studyvue-文件&#34;&gt;（1）在 compoents 下新建一个 Study.vue 文件&lt;/h2&gt;
&lt;p&gt;将 HelloWorld.vue 中的文件拷贝过来，删删改改&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a774d3cdaa4029a32fee477997abd9~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2在-views-文件夹下新建一个-studyvue-文件&#34;&gt;（2）在 views 文件夹下新建一个 Study.vue 文件&lt;/h2&gt;
&lt;p&gt;将 Home.vue 中的代码拷贝过来改改&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb26fb389af7452c909ac54842b6843f~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3修改-router-下的-indexjs&#34;&gt;（3）修改 router 下的 index.js&lt;/h2&gt;
&lt;p&gt;拷贝一下数组里的第一个对象元素，改改
&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33ed35d599dc452ca1077cc11eb33631~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4修改-src-根目录下的-appvue-文件&#34;&gt;（4）修改 src 根目录下的 App.vue 文件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f2f98e56ee7408bac64d0eb464644be~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>js基础</title>
      <link>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 20 Dec 2020 23:48:22 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80/</guid>
      
        <description>&lt;h1 id=&#34;1js中的变量&#34;&gt;1.JS中的变量&lt;/h1&gt;
&lt;h2 id=&#34;1变量提升和函数提升&#34;&gt;（1）变量提升和函数提升&lt;/h2&gt;
&lt;p&gt;变量提升和函数提升的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建阶段：JS解释器会找出需要提升的变量和函数，并给他们在内存中开辟好空间，变量的话会声明并且赋值为undefined，而函数会整个存储在内存中&lt;/li&gt;
&lt;li&gt;代码执行阶段：就可以使用上面进行提升的变量和函数了&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：let也会提升，但是let存在暂时性死区，所以在声明之前不可使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2letvarconst区别&#34;&gt;（2）let，var，const区别&lt;/h2&gt;
&lt;p&gt;参考这篇文章：&lt;a href=&#34;https://www.cnblogs.com/yukixing/p/11523259.html&#34;&gt;let与var的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;let定义的变量不会挂载到window对象上，而是形成一个块作用域，而var定义的变量会挂在到window上&lt;/p&gt;
&lt;h1 id=&#34;2applycallbind&#34;&gt;2.apply，call，bind&lt;/h1&gt;
&lt;h2 id=&#34;1applycallbind作用&#34;&gt;（1）apply，call，bind作用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;改变函数内部的this指向&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2applycallbind区别&#34;&gt;（2）apply，call，bind区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;apply接收的是一个数组类型的参数，call和bind接收的是一个参数列表&lt;/li&gt;
&lt;li&gt;apply和call返回的是一个值结果，而bind返回的是一个函数，需要再次进行调用&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;语法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;apply&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;func.apply(thisArg, [argsArray])&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;this，数组或类数组对象&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;结果值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;call&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function.call(thisArg, arg1, arg2, &amp;hellip;)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;this，参数列表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;结果值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bind&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function.bind(thisArg, arg1, arg2, &amp;hellip;)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;this，参数列表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;bind()方法返回的函数没有prototype属性，为什么没有prototype属性呢，因为如果把这个返回的函数做构造函数的话，那就需要将创建对象的this指向这个函数，但是这个函数在bind调用前就将this指向调用对象了，那么创建对象时又将这个this指向创建对象，不就矛盾了吗，所以bind()返回的函数没有prototype属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this);
            this.d = 50;
        }
        Function.prototype.myBind = function () {
            if (typeof this !== &#39;function&#39;) {
                throw new TypeError(&#39;调用者必须是函数&#39;)
            }
            var arg = arguments[0],
                slice = Array.prototype.slice,
                args = slice.call(arguments, 1),
                _that = this;
            return function () {
                return _that.apply(arg, args.concat(slice.call(arguments)));
            }
        }
        var c = new getInfo.myBind(obj, &#39;Software Engineer&#39;); // Uncaught TypeError: 调用者必须是函数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果bind方法作为构造函数的话，那么它里面的this就需要指向创建的对象，而bind中的this必须指向函数，所以此时就会报错。&lt;/p&gt;
&lt;p&gt;apply，call，bind用法展示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18,
            job: &#39;student&#39;
        }
        function getInfo(name) {
            console.log(name); // 小花
            console.log(this.age); // 18
            console.log(this.job); // student
        }
        // getInfo.apply(obj, [&#39;小花&#39;]);
        // getInfo.call(obj, &#39;小花&#39;);
        getInfo.bind(obj, &#39;小花&#39;)();
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(job, height) {
            console.log(job);
            console.log(height);
            console.log(this.age);
        }
        getInfo.bind(obj, &#39;student&#39;)(173);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;3手写apply&#34;&gt;（3）手写apply()&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;小王&#39;
        }
        function getInfo(job) {
            console.log(this.name);
            console.log(job);
        }
        // getInfo.apply();
        Function.prototype.myApply = function (context) {
            context = context || window;
            context.fn = this;
            let result;
            if (arguments[1]) {
                if (Array.isArray(arguments[1])) {
                    result = context.fn(...arguments[1]);
                } else {
                    console.error(&#39;Uncaught TypeError: CreateListFromArrayLike called on non-object&#39;);
                }

            } else {
                result = context.fn()
            }
            delete context.fn;
            return result;
        }
        getInfo.myApply(obj, [&#39;student&#39;]);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;4手写call&#34;&gt;（4）手写call()&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(job, name) {
            console.log(job);
            console.log(name);
            console.log(this.age);
        }
        // getInfo.call(obj, &#39;student&#39;);
        Function.prototype.myCall = function (context) {
            context = context || window;
            context.fn = this;
            let result;
            if (arguments[1]) {
                result = context.fn(...[...arguments].slice(1));
            } else {
                result = context.fn();
            }
            delete context.fn;
            return result;
        }
        getInfo.myCall(obj, &#39;student&#39;, &#39;小王&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;5bind&#34;&gt;(5)bind()&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;bind()的使用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 18
        }
        function getInfo(job, height) {
            console.log(job);
            console.log(height);
            console.log(this.age);
        }
        getInfo.bind(obj, &#39;student&#39;)(173);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;bind()返回的函数用new操作符调用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        Point.prototype.toString = function () {
            return this.x + &#39;,&#39; + this.y;
        }
        let p = new Point(1, 2);
        p.toString();
        let emptyObj = {};
        let YAxisPoint = Point.bind(emptyObj, 0);
        let axisPoint = new YAxisPoint(5);
        axisPoint.toString();
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Polyfill中bind()的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第一种😎😎：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        if (!Function.prototype.bind) (function () {
            var slice = Array.prototype.slice;
            Function.prototype.bind = function () {
                var thatFunc = this, thatArg = arguments[0];
                var args = slice.call(arguments, 1);
                if (typeof thatFunc !== &#39;function&#39;) {
                    throw new TypeError(&#39;Function.prototype.bind-&#39; +
                        &#39;what is trying to be bound is not callable&#39;);
                }
                return function () {
                    var funcArgs = args.concat(slice.call(arguments));
                    return thatFunc.apply(thatArg, funcArgs);
                }
            }
        })()	
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;仿写这种实现bind():&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(name, job) {
            console.log(name);
            console.log(job);
            console.log(this.age);
        }
        // getInfo.bind(obj, &#39;星空海绵&#39;)(&#39;Software Engineer&#39;);
        Function.prototype.myBind = function () {
            if (typeof this !== &#39;function&#39;) {
                throw new TypeError(&#39;调用者必须是函数&#39;)
            }
            var arg = arguments[0];
            var slice = Array.prototype.slice
            var args = slice.call(arguments, 1);
            var _that = this;
            return function () {
                return _that.apply(arg, args.concat(slice.call(arguments)))
            }
        }
        getInfo.myBind(obj, &#39;星空海绵&#39;)(&#39;Software Engineer&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面定义变量为什么要用var呢，因为用的是ES5，如果用let，都有ES6了，那我就直接用bind()了，而不是手写一个了。&lt;/p&gt;
&lt;p&gt;我们会发现使用上面这种手写bind()不支持new调用构造函数创建新的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        Point.prototype.toString = function () {
            console.log(&#39;toString方法&#39;);
        }
        Function.prototype.myBind = function () {
            if (typeof this !== &#39;function&#39;) {
                throw new TypeError(&#39;调用者必须是函数&#39;)
            }
            var arg = arguments[0];
            var slice = Array.prototype.slice
            var args = slice.call(arguments, 1);
            var _that = this;
            return function () {
                return _that.apply(arg, args.concat(slice.call(arguments)))
            }
        }
        let YAxisPoint = Point.myBind({}, 0);
        let axisPoint = new YAxisPoint(5);
        console.dir(axisPoint);
        axisPoint.toString();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看下上面这个代码的axisPoint是啥&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4e2cae6d63c4622a787e1734edb84fb~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们再看如果把上面代码中的myBind换成bind&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14e226d3266743b79b34f21bb86c1cce~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是说上面这种写法不支持new调用构造函数创建新的对象，所以说有了下面第二种方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，当使用new操作符绑定构造函数时，会忽略第一个参数
&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a9fa4cd63af47e4a5a68e1ccaace639~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this); // {age: 25}
        }
        getInfo.bind(obj, &#39;Software Engineer&#39;)();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上是没有用new调用的时候，getInfo中的this是指向obj的，没问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function A() {
            this.a = 100;
            console.log(this); // {a: 100}
        }
        let b = new A();
        console.log(b); // {a: 100}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4457b0a1ef74335bae1ae5286bb35e0~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this); // getInfo {}
        }
        var a = getInfo.bind(obj, &#39;Software Engineer&#39;);
        var b = new a();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上的代码你会发现getInfo中的this并不是obj，而是getInfo对象，上面我们也看到有说，当使用new操作符号时会忽略掉第一个参数，也就是让调用bind的函数中的this指向的第一个参数被忽略掉，然后我们再想想bind的作用，不就是改变函数得this指向吗，现在第一个参数都忽略了，那么bind是不是相当于没用了，仔细想想，确实可以这个理解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this); // getInfo {}
        }
        var a = getInfo.bind(obj, &#39;Software Engineer&#39;);
        var b = new a();
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this); // getInfo {}
        }
        var b = new getInfo(&#39;Software Engineer&#39;);
        console.log(b);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相对而言，上面这两段代码其实通过构造函数创建的b对象时一样的，也就是说当使用了new操作符号时，bind就没用，就是单纯的返回一个函数。理解了这个我们就会明白为什么之前的代码会存在不知new调用构造函数创建新对象了，那么就有了第二种方法。&lt;/p&gt;
&lt;p&gt;当使用new调用构造函数时，构造函数中的this是指向新创建的对象的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种😯😯：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用ES6的new.target加以理解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var obj = {
            age: 25
        }
        function getInfo(job, height) {
            console.log(this);
            this.d = 50;
        }
        Function.prototype.myBind = function () {
            if (typeof this !== &#39;function&#39;) {
                throw new TypeError(&#39;调用者必须是函数&#39;)
            }
            var arg = arguments[0],
                slice = Array.prototype.slice,
                args = slice.call(arguments, 1),
                _that = this;
            var fn1 = {};
            fn1 = new getInfo();
            return function () {
                if (new.target) {
                    return fn1
                } else {
                    return _that.apply(arg, args.concat(slice.call(arguments)));
                }
            }
        }
        var c = getInfo.myBind(obj, &#39;Software Engineer&#39;);
        var d = new c();
        console.log(d);
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;3原型链&#34;&gt;3.原型链&lt;/h1&gt;
&lt;h2 id=&#34;1对象和函数的原型&#34;&gt;（1）对象和函数的原型&lt;/h2&gt;
&lt;p&gt;每个对象都有一个原型，但是原型没有提供可以直接访问的属性，所以浏览器实现了一个__proto__属性，可以直接访问到对象的原型，每个函数都有一个__proto__和prototype属性，当函数当对象使用时，原型是__proto__，当函数作为构造函数使用时，原型是prototype。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当函数作为对象使用时&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        function Demo() { }
        Demo.__proto__.show = function () {
            console.log(&amp;quot;__proto__show&amp;quot;);
        }
        Demo.prototype.read = function () {
            console.log(&amp;quot;prototype-read&amp;quot;);
        }
        Demo.show();  // __proto__show
        Demo.read(); // Demo.read is not a function
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;当函数作为构造函数使用时&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        function Demo() { }
        let obj = new Demo();
        Demo.prototype.read = function () {
            console.log(&amp;quot;read&amp;quot;);
        }
        Demo.__proto__.show = function () {
            console.log(&amp;quot;show&amp;quot;);
        }
        obj.read(); // read
        obj.show(); // obj.show is not a function
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2原型链&#34;&gt;（2）原型链&lt;/h2&gt;
&lt;p&gt;对象可以通过__proto__属性找到不属于该对象的属性，__proto__将对象连接起来组成了原型链。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function A() { }
        function B() { }
        function C() { }
        C.prototype.show = function () {
            console.log(&#39;C构造函数&#39;);
        }
        B.prototype = new C();
        A.prototype = new B();
        let a = new A();
        a.show(); // C构造函数
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;4如何判断对象类型&#34;&gt;4.如何判断对象类型&lt;/h1&gt;
&lt;h2 id=&#34;1通过-objectprototypetostringcall&#34;&gt;（1）通过 Object.prototype.toString.call()&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            age: 20
        }
        let arr = [15, 20, 25];
        console.log(Object.prototype.toString.call(obj)); // [object Object]
        console.log(Object.prototype.toString.call(arr)); // [object Array]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2通过instanceof&#34;&gt;（2）通过instanceof&lt;/h2&gt;
&lt;p&gt;instanceof检测构造函数的prototype属性是不是出现在某个对象的原型链上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function A() { };
        function B() { };
        const b = new B();
        A.prototype = b;
        const a = new A();
        console.dir(a instanceof A); // true
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;5箭头函数&#34;&gt;5.箭头函数&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        var age = 10;
        let obj = {
            age: 20,
            say: () =&amp;gt; {
                return this.age;
            }
        }
        console.log(obj.say()); // 10
        let obj1 = {
            age: 30
        }
        obj1 = Object.create(obj);
        obj1.age = 30;
        console.log(obj1.say()); // 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过上面的代码我们会发现箭头函数say中的this并不会因为调用对象的改变而改变，而是一直指向全局对象window的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function getName() {
            let say = () =&amp;gt; {
                console.log(this.age);
            }
            say();
        }
        let obj = {
            age: 20,
            getName: getName
        }
        obj.getName(); // 20
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;箭头函数没有自己的this，它只会从自己作用域链的上层继承this。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;箭头函数中不能使用arguments和super以及new.target，同时箭头函数也不能作为构造函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;6this&#34;&gt;6.this&lt;/h1&gt;
&lt;h2 id=&#34;1谁调用函数函数里得this就指向谁&#34;&gt;（1）谁调用函数，函数里得this就指向谁&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        function getAge() {
            console.log(this.age)
        }
        var age = 1
        getAge()

        var obj = {
            age: 2,
            getAge: getAge
        }
        obj.getAge()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2new构造函数创建对象时构造函数内部的this指向创建的对象&#34;&gt;（2）new构造函数创建对象时，构造函数内部的this指向创建的对象&lt;/h2&gt;
&lt;h2 id=&#34;3可以通过applycallbind来改变函数内部的this指向&#34;&gt;（3）可以通过apply，call，bind来改变函数内部的this指向&lt;/h2&gt;
&lt;h1 id=&#34;7async和await&#34;&gt;7.async和await&lt;/h1&gt;
&lt;h2 id=&#34;1async和await对比promise&#34;&gt;（1）async和await对比Promise&lt;/h2&gt;
&lt;p&gt;async和await相比Promise，优势在于处理then调用链，代码更清晰，缺点是乱用await会导致性能问题，因为await会阻塞代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var a = 0;
        var b = async () =&amp;gt; {
            a = a + await 10;
            console.log(&#39;2&#39;, a);
            a = (await 10) + a;
            console.log(&#39;3&#39;, a);
        }
        b();
        a++;
        console.log(&#39;1&#39;, a);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;待深入&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;8generator&#34;&gt;8.generator&lt;/h1&gt;
&lt;h2 id=&#34;1generator是es6中新增的语法和promise一样都可以用来进行异步编程&#34;&gt;(1)generator是ES6中新增的语法，和Promise一样，都可以用来进行异步编程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        function* test() {
            let a = 1 + 2;
            yield 2;
            yield 3;
        }
        let b = test();
        console.log(b.next());
        console.log(b.next());
        console.log(b.next());
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2generator原理手写generator&#34;&gt;（2）generator原理，手写generator&lt;/h2&gt;
&lt;h1 id=&#34;9promise&#34;&gt;9.Promise&lt;/h1&gt;
&lt;h2 id=&#34;1promise是es6中新增的语法用来解决回调地狱问题&#34;&gt;（1）Promise是ES6中新增的语法，用来解决&lt;strong&gt;回调地狱&lt;/strong&gt;问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;什么是回调地狱？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2手写promise&#34;&gt;（2）手写Promise&lt;/h2&gt;
&lt;h1 id=&#34;10--和--的区别&#34;&gt;10. == 和 === 的区别&lt;/h1&gt;
&lt;p&gt;==只需要值相等即可，而 === 需要值和类型都相等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;11-垃圾回收&#34;&gt;11. 垃圾回收&lt;/h1&gt;
&lt;p&gt;主要的两种标记策略：&lt;strong&gt;标记清理&lt;/strong&gt; 和 &lt;strong&gt;引用计数&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;1标记清理&#34;&gt;（1）标记清理&lt;/h2&gt;
&lt;p&gt;JS最常用的垃圾回收策略就是标记清理。&lt;/p&gt;
&lt;p&gt;标记方法可以有多种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以当变量进入上下文中，反转某一位&lt;/li&gt;
&lt;li&gt;也可以维护“在上下文中”和“不在上下文中”这样的两个变量列表，可以把变量从一个列表移到另一个列表&lt;/li&gt;
&lt;li&gt;其它&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;垃圾回收程序运行时，会标记内存中存储的所有变量，然后，它会将所有上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是有待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。&lt;/p&gt;
&lt;h2 id=&#34;2引用计数&#34;&gt;（2）引用计数&lt;/h2&gt;
&lt;p&gt;另一种没那么常用的策略就是引用计数。&lt;/p&gt;
&lt;p&gt;引用计数存在解决不了循环引用的问题&lt;/p&gt;
&lt;h1 id=&#34;12闭包&#34;&gt;12.闭包&lt;/h1&gt;
&lt;h2 id=&#34;1定义&#34;&gt;（1）定义&lt;/h2&gt;
&lt;p&gt;函数A返回函数B，函数B中使用了函数A中的变量，函数B就被称为闭包。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        function A() {
            let age = 10;
            return function B() {
                console.log(age);
            }
        }
        A()();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这个例子age变量是存储在堆上的，因为JS的引擎可以分析出哪些变量需要存储在堆上，哪些变量需要存储在栈上。&lt;/p&gt;
&lt;p&gt;通过闭包解决变量作用域的问题，例如：解决var没有块作用域的问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        for (var i = 0; i &amp;lt; 4; i++) {
            (function (j) {
                setTimeout(function () {
                    console.log(j);
                })
            }
            )(i)
        }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2闭包的内存泄漏问题&#34;&gt;（2）闭包的内存泄漏问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用JS闭包很容易在不知不觉间造成内存泄漏问题&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;        let outer = function () {
            let name = &#39;Jake&#39;;
            return function () {
                return name;
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这段代码调用outer()会导致分配给name的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理name，因为闭包一直在引用着它，假如name的内容很大，那可能就是个大问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;13基本类型和引用类型&#34;&gt;13.基本类型和引用类型&lt;/h1&gt;
&lt;p&gt;基础类型存储在栈上，引用类型的地址存储在栈上，内容存储在堆上&lt;/p&gt;
&lt;h1 id=&#34;14eventloop&#34;&gt;14.Eventloop&lt;/h1&gt;
&lt;h2 id=&#34;1为什么js是单线程的&#34;&gt;（1）为什么JS是单线程的&lt;/h2&gt;
&lt;p&gt;作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这就决定了它只能是单线程，否则的话就会出现很多复杂的同步问题。假设JS有两个线程，一个线程往某个dom节点上添加内容，一个线程删除这个节点，那么应该以哪个线程为主呢，所以JS是单线程的就不会出现这种情况。&lt;/p&gt;
&lt;p&gt;JS并发事件模型&lt;/p&gt;
&lt;h2 id=&#34;1什么是eventloop&#34;&gt;（1）什么是Eventloop&lt;/h2&gt;
&lt;p&gt;主线程从&amp;quot;任务队列&amp;quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）&lt;/p&gt;
&lt;h2 id=&#34;2微任务和宏任务&#34;&gt;（2）微任务和宏任务&lt;/h2&gt;
&lt;h1 id=&#34;15回调函数&#34;&gt;15.回调函数&lt;/h1&gt;
&lt;h1 id=&#34;16settimeout&#34;&gt;16.setTimeout&lt;/h1&gt;
&lt;h2 id=&#34;1settimeout倒计时误差&#34;&gt;（1）setTimeout倒计时误差&lt;/h2&gt;
&lt;p&gt;为什么会出现这个问题呢，从刚才上面的JS事件循环机制我们就可以了解到，只有等同步任务全部执行完了才会执行异步任务，而setTimeout是一个宏任务，那么这个问题的实际应用在哪呢，电商的秒杀倒计时，那个肯定要准确，不同用户可能因为手机的性能加载页面的时长不一样，但是秒杀时间肯定得一样，所以说我们就需要写一个相对准确的倒计时了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(() =&amp;gt; {}, 3000);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有一行上面这样的代码，这不是说页面打开3秒后立即执行回调函数，而是页面打开后最快3秒执行回调函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        console.log(Date());
        setTimeout(() =&amp;gt; {
            console.log(&#39;我是定时器！&#39;);
            console.log(Date());
        }, 3000);
        for (let i = 0; i &amp;lt; 10000000000; i++) { }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你电脑性能好的话可以跑下上面这个例子，你会发现间隔时间并不是3秒&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f09409fa20dd411a9d5e0652354caca5~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;看我这打印的结果，中间差了14秒，这是为什么呢，因为执行前面的循环花费了很长的时间，setTimeout必须等循环执行完才会去执行自己的回调函数，所以这时候这个倒计时就不准确了，就需要我们自己写一个倒计时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let period = 60 * 1000 * 60 * 2,
            startTime = new Date().getTime(),
            count = 0,
            end = new Date().getTime() + period,
            interval = 1000,
            currentInterval = interval;
        function loop() {
            count++;
            let offset = new Date().getTime() - (startTime + count * interval),
                diff = end - new Date().getTime(),
                h = Math.floor(diff / (60 * 1000 * 60)),
                hdiff = diff % (60 * 1000 * 60),
                m = Math.floor(hdiff / (60 * 1000)),
                mdiff = hdiff % (60 * 1000),
                s = mdiff / (1000),
                sCeil = Math.ceil(s),
                sFloor = Math.floor(s),
                currentInterval = interval - offset;
            console.log(&#39;时：&#39; + h, &#39;分：&#39; + m, &#39;毫秒：&#39; + s,
                &#39;秒向上取整：&#39; + sCeil, &#39;代码执行时间：&#39; + offset,
                &#39;下次循环间隔&#39; + currentInterval)
            // 打印 时 分 秒 代码执行时间 下次循环间隔
            setTimeout(loop, currentInterval)
        }
        loop();
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;17防抖节流&#34;&gt;17.防抖节流&lt;/h1&gt;
&lt;h1 id=&#34;18数组降维&#34;&gt;18.数组降维&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat&#34;&gt;MDN参考&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1使用-es10-中的-flat&#34;&gt;（1）使用 &lt;strong&gt;ES10&lt;/strong&gt; 中的 &lt;strong&gt;flat()&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [50, 20, [50, 10, [1, [5, [20]]]]],
            arr1 = arr.flat(Infinity);
        console.log(arr); // [50, 20, Array(3)]
        console.log(arr1); //  [50, 20, 50, 10, 1, 5, 20]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2递归&#34;&gt;（2）递归&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [50, 20, [50, 10, [1, [5, [20]]]]],
            resArray = [];
        function flatten(array) {
            if (Array.isArray(array) === false) {
                throw new TypeError(&#39;参数类型错误&#39;);
            }
            array.forEach(item =&amp;gt; {
                if (Array.isArray(item)) {
                    flatten(item);
                } else {
                    resArray.push(item)
                }
            })
            return resArray;
        }
        console.log(arr); // [50, 20, Array(3)]
        console.log(flatten(arr)); // [50, 20, 50, 10, 1, 5, 20]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;3&#34;&gt;（3）&lt;/h2&gt;
</description>
      
    </item>
    
    <item>
      <title>JS数组去重</title>
      <link>https://xkhm.net/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Sun, 20 Dec 2020 18:12:21 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;文章类型：个人学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1双循环遍历&#34;&gt;1.双循环遍历&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1,5,6,1,9,9,2,1];
        arr.map((item,index) =&amp;gt; {
            arr.map((i,index1) =&amp;gt; {
                if(index !== index1 &amp;amp;&amp;amp; item === i){
                    arr.splice(index1,1);
                }
            })
        })
        console.log(arr);
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;        function unique(array){
            for (let i = 0; i &amp;lt; array.length; i++) {
                for(let j = i+1; j &amp;lt; array.length; j++){
                    if(array[i] === array[j]){
                        arr.splice(j,1);
                    }
                }
            }
            return arr;
        }
        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;下面一种方式更优，遍历的次数更少&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2-es6的set&#34;&gt;2. ES6的Set&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1,5,6,1,9,9,2,1];
        function unique(arr) {
            return Array.from(new Set(arr))
        }
        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;        let arr = [1, 5, 6, 1, 9, 9, 9, 9, 9, 2, 1];
        function unique(arr) {
            return [...new Set(arr)]
        }
        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;3利用indexof&#34;&gt;3.利用indexOf()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1,5,6,1,9,9,2,1];
        function unique(arr){
            if(!Array.isArray(arr)){
                console.log(&#39;type error&#39;);
                return;
            }
            let array = [];
            arr.map(item =&amp;gt; {
                if(array.indexOf(item) === -1){
                    array.push(item)
                }
            })
            return array;
        }
        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;4利用sort然后比较相邻元素是否相等&#34;&gt;4.利用sort(),然后比较相邻元素是否相等&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1, 5, 6, 1, 9, 9, 9, 9, 9, 2, 1];
        function unique(arr) {
            if (!Array.isArray(arr)) {
                console.log(&#39;type error!&#39;)
                return;
            }
            arr = arr.sort()
            let arrry = [arr[0]];
            arr.map((item, index) =&amp;gt; {
                if (index &amp;gt; 0 &amp;amp;&amp;amp; item !== arr[index - 1]) {
                    arrry.push(item)
                }
            });
            return arrry;
        }
        console.log(unique(arr)); // [1, 2, 5, 6, 9]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;5利用filter当找到的下标不等于当前下标时就证明这个元素在前面出现过排除掉&#34;&gt;5.利用filter(),当找到的下标不等于当前下标时就证明这个元素在前面出现过，排除掉&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1, 5, 6, 1, 9, 9, 9, 9, 9, 2, 1];
        function unique(arr) {
            if (!Array.isArray(arr)) {
                console.log(&#39;type error!&#39;)
                return;
            }
            return arr.filter((item, index) =&amp;gt; {
                return arr.indexOf(item) === index;
            })
        }

        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;秒啊！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;6利用reduce方法&#34;&gt;6.利用reduce()方法&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;        let arr = [1, 5, 6, 1, 9, 9, 9, 9, 9, 2, 1];
        function unique(arr) {
            if (!Array.isArray(arr)) {
                console.log(&#39;type error!&#39;)
                return;
            }
            return arr.reduce((prev, cur, index) =&amp;gt; prev.includes(cur) ? prev : [...prev, cur], []);
        }

        console.log(unique(arr)); // [1, 5, 6, 9, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;秀啊！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;总结：ES6下，以上几种方法首选第二种 new Set(),其次选择filter()和reduce()&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>日常小记</title>
      <link>https://xkhm.net/essaycontent/%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sat, 19 Dec 2020 23:01:15 +0800</pubDate>
      
      <guid>https://xkhm.net/essaycontent/%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%AE%B0/</guid>
      
        <description>&lt;h1 id=&#34;随笔&#34;&gt;随笔&lt;/h1&gt;
</description>
      
    </item>
    
    <item>
      <title>船到桥头自然直</title>
      <link>https://xkhm.net/lifecontent/%E8%88%B9%E5%88%B0%E6%A1%A5%E5%A4%B4%E8%87%AA%E7%84%B6%E7%9B%B4/</link>
      <pubDate>Sat, 19 Dec 2020 22:57:52 +0800</pubDate>
      
      <guid>https://xkhm.net/lifecontent/%E8%88%B9%E5%88%B0%E6%A1%A5%E5%A4%B4%E8%87%AA%E7%84%B6%E7%9B%B4/</guid>
      
        <description>&lt;h1 id=&#34;船到桥头自然直-all-will-be-good&#34;&gt;船到桥头自然直 All will be good&lt;/h1&gt;
</description>
      
    </item>
    
    <item>
      <title>JS基础之深浅拷贝</title>
      <link>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Sat, 19 Dec 2020 12:23:51 +0800</pubDate>
      
      <guid>https://xkhm.net/post/js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;文章类型：个人学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;友情提醒：个人学习笔记，可能有写的不对的地方，还请大佬们发现了提醒一下小弟我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1浅拷贝&#34;&gt;1.浅拷贝&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;定义：一个对象直接拷贝已存在对象的属性的引用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还没开始讲这篇文章的时候，让你自己去写一个拷贝，你会怎么写？&lt;/p&gt;
&lt;h2 id=&#34;1直接赋值&#34;&gt;（1）直接赋值&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;小明&#39;,
            age: 20,
            job: &#39;Software Engineer&#39;
        }
        let obj1 = obj;
        console.log(obj1 === obj); // true
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2借助-es6-的-objectassign-方法实现一个浅拷贝&#34;&gt;（2）借助 ES6 的 Object.assign() 方法实现一个浅拷贝&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;小明&#39;,
            age: 20,
            job: &#39;Software Engineer&#39;
        }
        let obj1 = Object.assign({}, obj);
        console.log(obj1 === obj); // false
        obj1.age = 10;
        console.log(obj.age); // 20
        console.log(obj1.age); // 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们会发现，当对象内部属性全部为基础类型时，改变新拷贝的对象属性值，并不会影响到原对象，换句话说，如果你的对象里都是基础类型，你想对他进行拷贝，使用浅拷贝即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;小明&#39;,
            age: 20,
            job: &#39;Software Engineer&#39;,
            friends: [&#39;小花&#39;, &#39;小丽&#39;]
        }
        let obj1 = Object.assign({}, obj);
        console.log(obj1 === obj); // false
        obj1.friends[1] = &#39;小萌&#39;;
        console.log(obj.friends); // [&amp;quot;小花&amp;quot;, &amp;quot;小萌&amp;quot;]
        console.log(obj1.friends); // [&amp;quot;小花&amp;quot;, &amp;quot;小萌&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当原对象中有属性时引用类型时，我们会发现改变新拷贝的引用类型属性值时，原对象的引用类型属性值也发生了改变，这就是拷贝的不够彻底，所以我们就需要深拷贝。&lt;/p&gt;
&lt;h2 id=&#34;3借助-es6-的展开语法实现浅拷贝&#34;&gt;（3）借助 ES6 的展开语法实现浅拷贝&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;小明&#39;,
            age: 20,
            job: &#39;Software Engineer&#39;,
            friends: [&#39;小花&#39;, &#39;小丽&#39;]
        }
        let obj1 = { ...obj };
        console.log(obj1 === obj);
        obj1.age = 10;
        obj.friends[0] = &#39;小美&#39;;
        console.log(obj.age); // 20
        console.log(obj1.age); // 10
        console.log(obj.friends); // [&amp;quot;小美&amp;quot;, &amp;quot;小丽&amp;quot;]
        console.log(obj1.friends); // [&amp;quot;小美&amp;quot;, &amp;quot;小丽&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;4遍历赋值的方法实现浅拷贝&#34;&gt;（4）遍历赋值的方法实现浅拷贝&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;小明&#39;,
            age: 20,
            job: &#39;Software Engineer&#39;,
            friends: [&#39;小花&#39;, &#39;小丽&#39;]
        }
        let obj1 = {};
        for (const item of Object.entries(obj)) {
            obj1[item[0]] = item[1];
        }
        console.log(obj1 === obj);
        obj1.age = 10;
        obj.friends[0] = &#39;小美&#39;;
        console.log(obj.age); // 20
        console.log(obj1.age); // 10
        console.log(obj.friends); // [&amp;quot;小美&amp;quot;, &amp;quot;小丽&amp;quot;]
        console.log(obj1.friends); // [&amp;quot;小美&amp;quot;, &amp;quot;小丽&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;2深拷贝&#34;&gt;2.深拷贝&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;复制一个一模一样的对象，不共享内存，修改一个对象，不会影响到另一个对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1利用jsonstringify&#34;&gt;（1）利用JSON.stringify()&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: &#39;小明&#39;,
            age: 20,
            job: &#39;Software Engineer&#39;,
            friends: [&#39;小花&#39;, &#39;小丽&#39;]
        }
        let obj1 = JSON.parse(JSON.stringify(obj));
        obj1.friends[0] = &#39;小美&#39;;
        console.log(obj.friends); // [&amp;quot;小花&amp;quot;, &amp;quot;小丽&amp;quot;]
        console.log(obj1.friends); // [&amp;quot;小美&amp;quot;, &amp;quot;小丽&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;缺陷：处理不了function对象、undefined以及symbol类型，原因时JSON.stringify()在处理这些类型，这些类型会被忽略，不会被处理，详情见 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify&#34;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2递归对每层数据实行遍历然后进行拷贝&#34;&gt;（2）递归，对每层数据实行遍历然后进行拷贝&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: {
                firstName: &#39;小&#39;,
                lastName: &#39;星&#39;,
            },
            age: 25,
            arr: [{ a: 10 }, { b: 50 }]
        }
        function copyObj(obj) {
            let obj1 = Array.isArray(obj) ? [] : {};
            for (const key in obj) {
                if (typeof obj[key] === &#39;object&#39;) {
                    obj1[key] = copyObj(obj[key]);
                } else {
                    obj1[key] = obj[key]
                }
            }
            return obj1
        }
        let obj2 = copyObj(obj);
        obj2.arr[0].a = 80;
        obj2.name.firstName = &#39;王&#39;;
        console.log(obj);
        console.log(obj2);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53baf66579f7458ca5b2a454a97364da~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3jquery中实现深拷贝&#34;&gt;（3）Jquery中实现深拷贝&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Jquery中实现深拷贝的原理也是递归&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: {
                firstName: &#39;小&#39;,
                lastName: &#39;星&#39;,
            },
            age: 25,
            sayName() { }
        }
        let obj2 = $.extend(true, {}, obj);
        obj2.name.firstName = &#39;王&#39;;
        console.log(obj.name.firstName); // 小
        console.log(obj2.name.firstName); // 王
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;4lodash中的-_defaultsdeephttpswwwlodashjscomdocslodashdefaultsdeep-方法&#34;&gt;（4）Lodash中的 &lt;a href=&#34;https://www.lodashjs.com/docs/lodash.defaultsDeep&#34;&gt;_.defaultsDeep()&lt;/a&gt; 方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;        let obj = {
            name: {
                firstName: &#39;小&#39;,
                lastName: &#39;星&#39;,
            },
            age: 25,
            arr: [{ a: 10 }, { b: 50 }]
        }
        let obj2 = _.defaultsDeep({}, obj);
        obj2.arr[0].a = 80;
        obj2.name.firstName = &#39;王&#39;;
        console.log(obj);
        console.log(obj2);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6414d847154446c58f89ddd86fe50884~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>一文详解JavaScript中的数组</title>
      <link>https://xkhm.net/post/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 19 Dec 2020 12:23:51 +0800</pubDate>
      
      <guid>https://xkhm.net/post/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbfce5de99fc415dbf604a9a4c820794~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近在重学JS基础，然后正好学到数组这，前期是通过看视频学习的，后来发现通过看视频学习进度实在是太慢了，所以又开始看书看文档学，然后就开始看“红宝书”（JavaScript高级程序设计）学习，看的最新的第四版的，数组这部分前期看视频学了一部分，后面又看书学了，前前后后学了有大概5天，当然是下班时间学习，学完了想写个全面的总结，然后就有了这篇文章，希望大佬们看了发现什么错误能在评论区指出，我会立马改正的。&lt;/p&gt;
&lt;h1 id=&#34;1数组介绍&#34;&gt;1.数组介绍&lt;/h1&gt;
&lt;h2 id=&#34;1什么是数组&#34;&gt;（1）什么是数组？&lt;/h2&gt;
&lt;p&gt;数组是使用单独的变量名来存储一系列的值的一个对象。&lt;/p&gt;
&lt;h2 id=&#34;2怎么创建数组&#34;&gt;（2）怎么创建数组？&lt;/h2&gt;
&lt;p&gt;创建数组有两种方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象方式创建数组&lt;/li&gt;
&lt;li&gt;字面量方式创建数组
创建数组可以通过上面这两种方式，当然也可以通过Array.of()这个函数创建数组。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;对象方式创建数组&#34;&gt;对象方式创建数组&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;let array = new Array();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也可以通过下面这种方式创建数组对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;let array = Array();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方式创建数组，对象也可以通过这两种方式创建，那么这种方式与上面那种方式有什么区别呢，这两种方式创建数组的区别就是内部this指向不同，一个指向调用者，一个指向全局的window对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;console.log(new Array(1)); // [empty]
console.log(new Array(1,2,3)); //  [1, 2, 3]
console.log(Array.of(1)); // [1]
console.log(Array.of(1,2,3)); // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一行代码是创建了一个长度为1的数组，因为没有值，这个位置会默认被undefined填充，也就是说打印结果 &lt;strong&gt;[empty] =&amp;gt; [undefined]&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;字面量的方式创建数组&#34;&gt;字面量的方式创建数组&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let arr = [];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方式创建数组非常的简单便捷,所以推荐使用这种方法创建数组&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用字面量的方式创建数组不会调用Array构造函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2array对象介绍&#34;&gt;2.Array对象介绍&lt;/h1&gt;
&lt;h2 id=&#34;1array介绍&#34;&gt;（1）Array介绍&lt;/h2&gt;
&lt;p&gt;上面我们也用了一个Array的方法,就是Array.of(),那么Array跟数组到底是什么关系呢，根据MDN上的定义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JavaScript的 Array 对象是用于构造数组的全局对象，数组是类似于列表的高阶对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;换句话说就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Array对象是js内置的用于构造数组的全局对象，数组身上的方法都是继承于Array对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们来打印看下这个Array对象的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e9ea1db2a6447e6834c33bdbe28de86~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们从这个打印结果可以看出Array下面主要有三个 &lt;strong&gt;&lt;em&gt;&lt;strong&gt;私有&lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt; 方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法介绍&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;JavaScript 版本&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否会改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;from()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将类数组结构转换为数组实例&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ES6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;isArray()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;判断数组是否为数组类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ES6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;of()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将一组参数转换为数组实例&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ES6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2arrayfrom&#34;&gt;（2）Array.from()&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;object&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需，要转换为数组的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mapFunction&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选，数组中每个元素要调用的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;thisValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选，映射函数(mapFunction)中的 this 对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;新的数组实例&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;//  1.类数组对象
let obj = {
    1: &#39;techerM&#39;,
    2: 15,
    length: 2
};
console.log(Array.from(obj)); // [&amp;quot;techerM&amp;quot;, 15]
// 2.字符串
let str = &#39;阿星&#39;;
console.log(Array.from(str)); // [&amp;quot;阿&amp;quot;, &amp;quot;星&amp;quot;]
// 3.集合
let s = new Set().add(1)
                 .add(2)
                 .add(1)
                 .add(4);
console.log(Array.from(s)); // [1, 2, 4]
// 4.第二个参数，可操作数组中的每个元素
let numbersObj = {
    0:1,
    1:2,
    2:3,
    3:2,
    length: 3
};
console.log(Array.from(numbersObj,item =&amp;gt; item*3));//[3, 6, 9]
console.log(numbersObj); // {0: 1, 1: 2, 2: 3, 3: 2, length: 3}
// 5.第三个参数，指定第二个参数（函数）中this的指向
let numArray = [1,2,3];
var name = &#39;小花&#39;;
let res1 = Array.from(numArray,function(item){
    return this.name;
})
let res2 = Array.from(numArray,function(item){
    return this.name;
},{name:&#39;小丽&#39;})
console.log(res1); // [&amp;quot;小花&amp;quot;, &amp;quot;小花&amp;quot;, &amp;quot;小花&amp;quot;]
console.log(res2); // [&amp;quot;小丽&amp;quot;, &amp;quot;小丽&amp;quot;, &amp;quot;小丽&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Array.from()是Array对象的私有方法，并不是Array原型prototype下的方法，所以数组继承不到这个方法，数组是没有这个方法的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2.Array.from()第一个参数类数组对象的条件为：存在length属性，数据为可索引结构，例如下面这个对象就不可进行迭代，因为没有可索引结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let obj = {
    name: &#39;小丽&#39;,
    value: 100,
    length: 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;3.Array.from()方法不会改变原数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;4.Array.from()中第3个参数设置第二个参数（函数）this的指向，不适用于箭头函数，也就是说如果你第二个参数用的箭头函数的写法，那么你设置第3个参数时将不起作用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;arrayfrom方法用于哪些地方&#34;&gt;Array.from()方法用于哪些地方&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;将字符串转换为数组&lt;/li&gt;
&lt;li&gt;将集合和映射转换为数组&lt;/li&gt;
&lt;li&gt;可以对现有数组进行浅复制&lt;/li&gt;
&lt;li&gt;可应用于任何符合条件（length和索引）的可迭代对象&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3arrayof&#34;&gt;（3）Array.of()&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;elementN&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任意个参数，将按顺序成为返回数组中的元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;新的数组实例&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;// 一组参数
console.log(Array.of(1,2,3)); //  [1, 2, 3]
// 通过 Array.of() 创建数组对象
let arr = Array.of(1);
console.log(arr); // [1]
// new Array() 创建数组对象
let arr1 = new Array(1);
console.log(arr1); // [empty]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过Array.of()创建对象的方式弥补了通过 &lt;strong&gt;new Array&lt;/strong&gt; 创建对象传一个参数创建对象的缺陷。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4arrayisarray&#34;&gt;（4）Array.isArray()&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;obj&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需，要判断的对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;布尔值，如果对象是数组返回 true，否则返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;green&#39;];
let name = &#39;小王&#39;;
let age = 18;
console.log(Array.isArray(colors)); // true
console.log(Array.isArray(name)); // false
console.log(Array.isArray(age)); // false
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;3检测数组&#34;&gt;3.检测数组&lt;/h1&gt;
&lt;p&gt;一般我们在js中检测数据类型通常用 &lt;strong&gt;typeof&lt;/strong&gt; 关键字，但是 &lt;strong&gt;typeof&lt;/strong&gt; 并不能分开对象与数组，检测数组时返回的也是 &lt;strong&gt;object&lt;/strong&gt;，所以我们就需要用其它的办法来区分&lt;strong&gt;对象&lt;/strong&gt;与&lt;strong&gt;数组&lt;/strong&gt;了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Array.isArray()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个布尔类型的值，是数组则返回true，反之false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;instanceof&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个布尔类型的值，是数组则返回true，反之false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Object.prototype.toString.call()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回详细的具体类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let array = [1,2];
let obj = {name: &#39;小明&#39;};
console.log(Array.isArray(array)); // true
console.log(Array.isArray(obj)); // false
console.log(array instanceof Array); // true
console.log(obj instanceof Array); // false
console.log(Object.prototype.toString.call(array)); // [object Array]
console.log(Object.prototype.toString.call(obj)); // [object Object]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这个三个方法都可以用来区分&lt;strong&gt;对象&lt;/strong&gt;和&lt;strong&gt;数组&lt;/strong&gt;，平常我们使用还是最好使用  &lt;strong&gt;Array.isArray()&lt;/strong&gt; 这个方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通常我们使用instanceof是假定只有一个全局上下文，如果在多个框架页面中检测数组可能会有问题，因为我们并不能保证所有框架里的&lt;strong&gt;Array构造函数&lt;/strong&gt;相同，所以最好使用&lt;strong&gt;Array.isArray()&lt;/strong&gt; 这个方法判断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;4数组中的方法&#34;&gt;4.数组中的方法&lt;/h1&gt;
&lt;h2 id=&#34;数组中的方法总览&#34;&gt;数组中的方法总览&lt;/h2&gt;
&lt;p&gt;首先我们从控制台打印看一下数组：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;console.log([]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ada2a185e1648348f0a25f1577e132c~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从上图中我们可以看到数组中有32个方法，全部是挂在数组原型 **_&lt;em&gt;proto&lt;/em&gt;_** 上的,然后下面我们就来看一下这些数组方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;push()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;向数组的末尾添加一个或多个元素，并返回新的长度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pop()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;删除并返回数组的最后一个元素&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;unshift()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;向数组的开头添加一个或更多元素，并返回新的长度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;shift()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把数组的第一个元素从其中删除，并返回第一个元素的值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;copyWithin()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fill()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;向一个已有的数组中插入全部或部分相同的值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;reverse()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于颠倒数组中元素的顺序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sort()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用原地算法对数组的元素进行排序，并返回数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;splice()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;向/从数组中添加/删除项目，然后返回被删除的项目&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;slice()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可提取字符串的某个部分，并以新的字符串返回被提取的部分&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;concat()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;join()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;every()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组中每一项都运行传入的函数，如果对每一项函数都返回true，则这个方法返回true&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;some()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组中每一项都运行传入的函数，如果有一项函数返回true，则这个方法返回true&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;filter()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组每一项都运行传入的函数，函数返回true的项会组成数组之后返回&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;map()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;forEach()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组每一项都运行传入的函数，没有返回值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;keys()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数组索引的迭代器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;values()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数组元素的迭代器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;entries()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回 索引/值 对的迭代器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;reduce()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组中的每个元素执行一个由您提供的reducer函数，将其结果汇总为单个返回值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;reduceRight()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从数组的末尾向前将数组中的数组项做累加&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;indexOf()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;lastIndexOf()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回查找元素在数组中的位置，从数组末尾开始向前查找&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;includes()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来判断一个数组是否包含一个指定的值，如果包含则返回 true，否则返回false&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;find()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;findIndex()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;toSting()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回由数组中每个值的等效字符串拼接而成的一个用逗号分隔的字符串&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;toLocaleString()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个逗号分隔的数组值的字符串&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;constructor()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数组函数的引用，也就是调用这个方法的数组本身&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flat()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;会按照一个可指定的深度递归遍历数组，将所有元素与遍历到的子数组中的元素合并为一个新数组返回&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flatMap()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;使用映射函数映射每个元素，然后将结果压缩成一个新数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;上面是数组中的所有方法，然后下面我们分10类来介绍这些方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;栈和队列方法（&lt;strong&gt;4个&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;复制和填充方法（&lt;strong&gt;2个&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;排序方法（&lt;strong&gt;2个&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;操作方法（&lt;strong&gt;4个&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;迭代方法（&lt;strong&gt;5个&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;迭代器方法（&lt;strong&gt;3个&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;归并方法（&lt;strong&gt;2个&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;搜索查找方法（&lt;strong&gt;5个&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;转换方法（&lt;strong&gt;2个&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;扁平化方法（&lt;strong&gt;2个&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1栈和队列方法&#34;&gt;（1）栈和队列方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;栈是一种后进先出的数据结构，也就是最新添加的项先被删除。数据项的插入（称为&lt;strong&gt;推入，push&lt;/strong&gt;）和删除（称为&lt;strong&gt;弹出，pop&lt;/strong&gt;）只在栈的一个地方发生，即栈顶。js为数组提供了&lt;strong&gt;push()&lt;/strong&gt; 和 &lt;strong&gt;pop()&lt;/strong&gt; 方法，以实现类似栈的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;push&#34;&gt;push()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;push()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;向数组的末尾添加一个或多个元素&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把指定的值添加到数组后的新长度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;newelement1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。要添加到数组的第一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;newelement2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。要添加到数组的第二个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;newelementX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。可添加多个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let arr = [&#39;js&#39;,&#39;css&#39;,&#39;html&#39;];
console.log(arr.push(&#39;go&#39;,&#39;node.js&#39;)); // 5
console.log(arr); //  [&amp;quot;js&amp;quot;, &amp;quot;css&amp;quot;, &amp;quot;html&amp;quot;, &amp;quot;go&amp;quot;, &amp;quot;node.js&amp;quot;]

let arr1 = [&#39;js&#39;,&#39;css&#39;,&#39;html&#39;];
let array = [&#39;go&#39;,&#39;node.js&#39;];
console.log(arr1.push(...array)); // 5
console.log(arr1); // [&amp;quot;js&amp;quot;, &amp;quot;css&amp;quot;, &amp;quot;html&amp;quot;, &amp;quot;go&amp;quot;, &amp;quot;node.js&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;小知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们也可以通过  &lt;strong&gt;array[array.length] = &amp;lsquo;XXX&amp;rsquo;&lt;/strong&gt; 这种方式往数组后面添加元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let arr = [&#39;js&#39;,&#39;css&#39;,&#39;html&#39;];
arr[arr.length] = &#39;go&#39;;
console.log(arr); // [&amp;quot;js&amp;quot;, &amp;quot;css&amp;quot;, &amp;quot;html&amp;quot;, &amp;quot;go&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;pop&#34;&gt;pop()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pop()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;删除并返回数组的最后一个元素&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回被删除的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无需传参&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无需描述&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;]
console.log(colors.pop()); // blue
console.log(colors); // [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;小知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们也可以通过  &lt;strong&gt;array.length = array.length - 1&lt;/strong&gt; 这种方式从数组末尾删除元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;];
colors.length = colors.length - 1;
console.log(colors); //  [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;push()和pop()一起使用就构成了后进先出的栈结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let array = [];
console.log(array.push(&#39;red&#39;,&#39;green&#39;)); // 2
console.log(array); // [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;]
console.log(array.pop()); // green
console.log(array); // [&amp;quot;red&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;unshift&#34;&gt;unshift()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;unshift()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;向数组的开头添加一个或更多元素&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把指定的值添加到数组后的新长度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;newelement1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。向数组添加的第一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;newelement2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。向数组添加的第二个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;newelementX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。可添加若干个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;white&#39;];
console.log(colors.unshift(&#39;red&#39;,&#39;blue&#39;)); // 3
console.log(colors); // [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;white&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;shift&#34;&gt;shift()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;shift()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把数组的第一个元素从其中删除&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回第一个元素的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无需传参&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无需描述&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;black&#39;];
console.log(colors.shift()); // red
console.log(colors); // [&amp;quot;black&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;unshift()和shift()一起使用也构成了后进先出的栈结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;unshift()和pop()一起使用构成了先进先出的队列结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;push()和shift()一起使用也构成了先进先出的队列结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2复制和填充方法&#34;&gt;（2）复制和填充方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;ES6新增了两个方法：批量复制方法 &lt;strong&gt;copyWithin()&lt;/strong&gt;,以及填充数组方法 &lt;strong&gt;fill()&lt;/strong&gt;。使用这两个方法都不会改变数组的大小。同时这两个方法都是包含开始索引，不包含结束索引的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;copywithin&#34;&gt;copyWithin()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;copyWithin()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;浅复制数组的一部分到同一数组中的另一个位置&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回修改后的原数组&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;target&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。复制到指定目标索引位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;start&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。元素复制的起始位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;end&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。停止复制的索引位置 (默认为 array.length)。如果为负值，表示倒数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let ints = [0,1,2];
let copyRes = ints.copyWithin(1);
console.log(copyRes); //  [0, 0, 1]
console.log(ints); //  [0, 0, 1]
console.log(copyRes === ints); // true
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;fill&#34;&gt;fill()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fill()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;向一个已有的数组中插入全部或部分相同的值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回填充后的原数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;value&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。填充的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;start&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。开始填充位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;end&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。停止填充位置 (默认为 array.length)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let zeroes = [0,0,0,0,0];
let zeroesRes = zeroes.fill(5);
console.log(zeroes); // [5, 5, 5, 5, 5]
console.log(zeroesRes === zeroes); // true
console.log(zeroes.fill(3,1)); // [5, 3, 3, 3, 3]
console.log(zeroes); // [5, 3, 3, 3, 3]
console.log(zeroes.fill(1,3,5)); // [5, 3, 3, 1, 1]
console.log(zeroes); // [5, 3, 3, 1, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;copyWithin()和fill()会忽略超出数组边界，零长度以及方向相反的索引范围&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let ints = [0,1,2,3];
// 索引超出边界，忽略
ints.copyWithin(1,10,13);
console.log(ints); // [0,1,2,3]
// 索引过低，超出边界，忽略
ints.copyWithin(2,-15,-12);
console.log(ints); // [0,1,2,3]
// 索引反向，忽略
ints.copyWithin(1,3,1);
console.log(ints); // [0,1,2,3]
// 部分索引可用，填充可用索引部分
ints.copyWithin(1,2,6);
console.log(ints); // [0,2,3,3]
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let zeroes = [0,0,0,0,0];
// 当开始索引和结束索引取负值时，相当于：将开始索引和结束索引都加上 zeroes.length
// zeroes.fill(8,1,4);
zeroes.fill(8,-4,-1);
console.log(zeroes); // [0,8,8,8,0]
// 索引超出边界，忽略
zeroes.fill(1,10,15);
console.log(zeroes); // [0,8,8,8,0]
// 索引过低，超出边界，忽略
zeroes.fill(1,-15,-12);
console.log(zeroes); // [0,8,8,8,0]
// 索引反向，忽略
zeroes.fill(1,3,1);
console.log(zeroes); // [0,8,8,8,0]
// 部分索引可用，填充可用索引部分
zeroes.fill(1,3,10);
console.log(zeroes); // [0, 8, 8, 1, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;3排序方法&#34;&gt;（3）排序方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;数组中有两个方法可以用来对元素重新排序：&lt;strong&gt;reverse()&lt;/strong&gt; 和 &lt;strong&gt;sort()&lt;/strong&gt;，顾名思义，reverse()方法就是将数组元素反向排列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;reverse&#34;&gt;reverse()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;reverse()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于颠倒数组中元素的顺序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回颠倒后的原数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无需参数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无需描述&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let value = [1,2,3,4,5,6];
console.log(value.reverse()); // [6, 5, 4, 3, 2, 1]
console.log(value); // [6, 5, 4, 3, 2, 1]
console.log(value.reverse() === value); // true
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;sort&#34;&gt;sort()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sort()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用原地算法对数组的元素进行排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回排序后的原数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sortby&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。规定排序顺序。必须是函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当不传参数时&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;默认情况下，&lt;strong&gt;sort()&lt;/strong&gt; 会按照升序重新排列数组元素，既最小的值在前面，最大的值在后面。为此，&lt;strong&gt;sort()&lt;/strong&gt; 会在每一项上调用&lt;strong&gt;String()&lt;/strong&gt; 转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会把数组转换为字符串再比较排序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let value = [1,2,3,5,8,9,10,16,20,50];
console.log(value.sort()); //  [1, 10, 16, 2, 20, 3, 5, 50, 8, 9]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传入比较函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这时候排序的结果就是我们结果就是我们想要的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let value = [1,2,3,5,8,9,10,16,20,50];
function compare(a,b) {
    if(a &amp;lt; b) return -1
    else if(a &amp;gt; b) return 1
    else return 0;
}
value.sort(compare);
console.log(value); // [1, 2, 3, 5, 8, 9, 10, 16, 20, 50]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当想要结果按降序排列的话将if条件反过来即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let value = [1,2,3,5,8,9,10,16,20,50];
function compare(a,b) {
    if(a &amp;gt; b) return -1
    else if(a &amp;lt; b) return 1
    else return 0;
}
value.sort(compare);
console.log(value); // [50, 20, 16, 10, 9, 8, 5, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码也可简写为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let value = [1,2,3,5,8,9,10,16,20,50];
value.sort((a,b) =&amp;gt; a &amp;gt; b ? -1 : a &amp;gt; b ? 1 : 0);
console.log(value); // [50, 20, 16, 10, 9, 8, 5, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码还可简写为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let value = [1,2,3,5,8,9,10,16,20,50];
value.sort((a,b) =&amp;gt; b - a); // a - b 升序，b - a 降序
console.log(value); // [50, 20, 16, 10, 9, 8, 5, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组对象按某个属性排序&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let array = [
    {&#39;name&#39;:&#39;js&#39;,&#39;grade&#39;:80},
    {&#39;name&#39;:&#39;java&#39;,&#39;grade&#39;:50},
    {&#39;name&#39;:&#39;go&#39;,&#39;grade&#39;:100},
]
array.sort(function(a,b) {
    return b.grade - a.grade;
})
console.log(array);
// [{&#39;name&#39;:&#39;go&#39;,&#39;grade&#39;:100},{&#39;name&#39;:&#39;js&#39;,&#39;grade&#39;:80},{&#39;name&#39;:&#39;java&#39;,&#39;grade&#39;:50}]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;手写一个sort函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;function sort(array,callback) {
    for (const n in array) {
        for (const m in array) {
            if(callback(array[n],array[m]) &amp;lt; 0){
                const temp = array[n];
                array[n] = array[m];
                array[m] = temp;
            }
        }
    }
    return array;
};
let arr = [10,52,2,3,7];
sort(arr,function(a,b){
    return a - b
})
console.log(arr); // [2, 3, 7, 10, 52] 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果只是想反转数组的顺序，reverse()更简单也更快。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4操作方法&#34;&gt;（4）操作方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对于数组中的元素，我们有很多操作方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;splice&#34;&gt;splice()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;splice()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;向/从数组中添加/删除项目&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回被删除元素的组成的数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;howmany&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。要删除的项目数量。如果设置为 0，则不会删除项目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。向数组添加的新项目&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let nums = [1,2,3,4,5,6,7,8,9,10];
console.log(nums.splice(0,2)); // [1, 2]
console.log(nums); // [3, 4, 5, 6, 7, 8, 9, 10]
let colors = [&#39;red&#39;,&#39;green&#39;];
console.log(colors.splice(0,1,&#39;black&#39;,&#39;white&#39;)); // [&amp;quot;red&amp;quot;]
console.log(colors); // [&amp;quot;black&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;green&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果&lt;strong&gt;splice()&lt;/strong&gt; 不传参数时，不会删除任何元素，返回一个空数组，当传一个参数时，从当前下标对应的元素（包含当前下标对应的元素）往后删除，返回被删除元素的组成的数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let nums = [1,2,3,4,5,6,7,8,9,10];
console.log(nums.splice()); // []
console.log(nums); // [1,2,3,4,5,6,7,8,9,10]
console.log(nums.splice(3)); // [4, 5, 6, 7, 8, 9, 10]
console.log(nums); // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;slice&#34;&gt;slice()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;slice()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可提取字符串的某个部分&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;以新数组的形式返回被提取的部分&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;start&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。规定从何处开始选取，包含这个位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;end&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。规定从何处结束选取，不包含这个位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;blue&#39;];
let colors2 = colors.slice();
let colors3 = colors.slice(1);
let colors4 = colors.slice(0,1);
console.log(colors); //  [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;]
console.log(colors2); // [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;]
console.log(colors3); // [&amp;quot;blue&amp;quot;]
console.log(colors4); // [&amp;quot;red&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果&lt;strong&gt;slice()&lt;/strong&gt; 的参数有负值，那么就以当前数组长度加上这个负值的结果确定位置。当数组长度加上这个负值仍然为负值，那么返回空数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt; let colors = [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;];
// 这个数组的长度为3，所以colors.slice(-3,-1) 相当于 colors.slice(0,2)
console.log(colors.slice(-3,-1)); //  [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;]
console.log(colors.slice(0,2)); //  [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;]

// 因为colors.slice(-6,-4) 加上数组长度分别为 -3，-1，所以返回空值
// 但是colors.slice(-6,-4) 结果并不等于 colors.slice(-3,-1)的结果
// 因为 colors.slice(-3,-1) 相当于 colors.slice(0,2)
console.log(colors.slice(-6,-4)); // []
console.log(colors.slice(-3,-1)); // [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;]

// colors.slice(-8,-1) 加上数组长度分别为 -5，2，有一部分是在数组索引范围内的
// 所以这部分是生效的
console.log(colors.slice(-8,-1)); // [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;]

// colors.slice(-5,2) 加上数组长度为 -2，2
// 但是 colors.slice(-2,2) 加上数组长度为 1，2
// 所以他们结果是不同的
console.log(colors.slice(-5,2)); // [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;]
console.log(colors.slice(-2,2)); // [&amp;quot;blue&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;concat&#34;&gt;concat()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;concat()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于合并两个或多个数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回合并后的新创建的数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arrayX&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;concat不仅可以合并数组，也可以将字符串合并到数组中去&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;green&#39;];
let newColors = [&#39;brown&#39;,&#39;blue&#39;];
console.log(colors.concat(newColors)); // [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;brown&amp;quot;, &amp;quot;blue&amp;quot;]
console.log(colors.concat([&#39;yellow&#39;],newColors)); // [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;yellow&amp;quot;, &amp;quot;brown&amp;quot;, &amp;quot;blue&amp;quot;]
console.log(colors.concat(&#39;white&#39;,newColors)); // [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;brown&amp;quot;, &amp;quot;blue&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;concat()&lt;/strong&gt; 将字符串合并到数组中有点类似于&lt;strong&gt;push()&lt;/strong&gt; ，但是&lt;strong&gt;concat()&lt;/strong&gt; 不会改变原数组，而&lt;strong&gt;push()&lt;/strong&gt; 会改变原数组，同时，&lt;strong&gt;concat()&lt;/strong&gt; 的返回值是合并后的新数组，而&lt;strong&gt;push()&lt;/strong&gt; 的返回值是添加元素后的原数组的长度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;];
console.log(colors.concat(&#39;green&#39;,&#39;blue&#39;)); // [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;]
console.log(colors); // [&amp;quot;red&amp;quot;]

let newColors = [&#39;red&#39;];
console.log(colors.push(&#39;green&#39;,&#39;blue&#39;)); // 3
console.log(colors); // [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;join&#34;&gt;join()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;join()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将一个数组的所有元素连接成一个字符串并返回&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回连接后的字符串&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;separator&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;];
console.log(colors.join()); // red,green,blue
console.log(colors.join(&#39;,&#39;)); // red,green,blue
console.log(colors.join(&#39;||&#39;)); // red||green||blue
console.log(colors.join(undefined)); // red,green,blue
console.log(colors.join(null)); // rednullgreennullblue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当不给&lt;strong&gt;join()&lt;/strong&gt; 传入任何参数，或者传入&lt;strong&gt;undefined&lt;/strong&gt; ，则仍然使用逗号作为分隔符。如果数组中某一项是&lt;strong&gt;null&lt;/strong&gt; 或&lt;strong&gt;undefined&lt;/strong&gt; ，则在join() 返回的结果中会以空字符串表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;]; 
console.log(colors.join(undefined)); // red,green,blue
let colors1 = [&#39;red&#39;,null,undefined,&#39;blue&#39;]; 
console.log(colors1.join()); // red,,,blue
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;5迭代方法&#34;&gt;（5）迭代方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; 为数组定义了5个迭代方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;every&#34;&gt;every()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;every()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组中每一项都运行传入的函数，如果对 &lt;strong&gt;每一项&lt;/strong&gt; 函数都返回 &lt;strong&gt;true&lt;/strong&gt; ，则这个方法返回 &lt;strong&gt;true&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个布尔类型的值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function(currentValue, index,arr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。函数，数组中的每个元素都会执行这个函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;thisValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。对象作为该执行回调时使用，传递给函数，用作 &amp;ldquo;this&amp;rdquo; 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;第一个参数（函数）的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。当前元素的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素属于的数组对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5,4,3,2,1];
let everyResult = numbers.every((item,index,numbers) =&amp;gt; item &amp;gt; 2);
console.log(everyResult); // false
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若收到一个空数组，此方法在一切情况下都会返回 true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [];
let everyResult = numbers.every((item,index,numbers) =&amp;gt; item &amp;gt; 5);
console.log(everyResult); // true
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;some&#34;&gt;some()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;some()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组中每一项都运行传入的函数，如果 &lt;strong&gt;有一项&lt;/strong&gt; 函数返回 &lt;strong&gt;true&lt;/strong&gt; ，则这个方法返回 &lt;strong&gt;true&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个布尔类型的值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function(currentValue, index,arr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。函数，数组中的每个元素都会执行这个函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;thisValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。对象作为该执行回调时使用，传递给函数，用作 &amp;ldquo;this&amp;rdquo; 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;第一个参数（函数）的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。当前元素的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素属于的数组对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; &lt;strong&gt;every()&lt;/strong&gt; 和 &lt;strong&gt;some()&lt;/strong&gt; 接收的参数是一样的，只是 &lt;strong&gt;every()&lt;/strong&gt; 需要函数 &lt;strong&gt;每一项&lt;/strong&gt; 都返回 &lt;strong&gt;true&lt;/strong&gt; ，这个方法才会返回 &lt;strong&gt;true&lt;/strong&gt; ，而 &lt;strong&gt;some()&lt;/strong&gt; 只需要函数 &lt;strong&gt;某一项&lt;/strong&gt; 返回 &lt;strong&gt;true&lt;/strong&gt; ，这个方法就会返回 &lt;strong&gt;true&lt;/strong&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5,4,3,2,1];
let everyResult = numbers.every((item,index,numbers) =&amp;gt; item &amp;gt; 2);
console.log(everyResult); // false
let someResult = numbers.some((item,index,numbers) =&amp;gt; item &amp;gt; 2);
console.log(someResult); // true
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;filter&#34;&gt;filter()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;filter()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组每一项都运行传入的函数，函数返回 &lt;strong&gt;true&lt;/strong&gt; 的项会组成数组之后返回&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function(currentValue, index,arr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。函数，数组中的每个元素都会执行这个函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;thisValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。对象作为该执行回调时使用，传递给函数，用作 &amp;ldquo;this&amp;rdquo; 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;第一个参数（函数）的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。当前元素的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素属于的数组对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5,4,3,2,1];
let filterResult = numbers.filter((item,index,numbers) =&amp;gt; item &amp;gt; 2);
console.log(filterResult); // [3, 4, 5, 4, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;map&#34;&gt;map()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;map()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function(currentValue, index,arr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。函数，数组中的每个元素都会执行这个函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;thisValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。对象作为该执行回调时使用，传递给函数，用作 &amp;ldquo;this&amp;rdquo; 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;第一个参数（函数）的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。当前元素的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素属于的数组对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5,4,3,2,1];
let mapResult = numbers.map((item,index,number) =&amp;gt; item*2);
console.log(mapResult); //  [2, 4, 6, 8, 10, 8, 6, 4, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从上面的代码以及描述看，&lt;strong&gt;fliter()&lt;/strong&gt; 和 &lt;strong&gt;map()&lt;/strong&gt; 好像没什么区别，事实上，这两个方法还是有区别的，&lt;strong&gt;fliter()&lt;/strong&gt; 返回的数组元素个数可能会变化，但是元素本省不会变化，也就是说 &lt;strong&gt;fliter()&lt;/strong&gt; 返回的新数组一定是跟原数组一样的内容或者原数组内容的一部分，元素不会改变，而 &lt;strong&gt;map()&lt;/strong&gt; 返回的新数组元素个数不变，但是按照一定的条件转换，数组元素可能会变化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5,4,3,2,1];
let filterResult = numbers.filter((item,index,number) =&amp;gt; item * 2);
let mapResult = numbers.map((item,index,number) =&amp;gt; item * 2);
let filterResult1 = numbers.filter((item,index,number) =&amp;gt; item &amp;gt; 2);
let mapResult1 = numbers.map((item,index,number) =&amp;gt; item &amp;gt; 2);
console.log(filterResult); //  [1, 2, 3, 4, 5, 4, 3, 2, 1]
console.log(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2]
console.log(filterResult1); //  [3, 4, 5, 4, 3]
console.log(mapResult1); //  [false, false, true, true, true, true, true, false, false]
console.log(numbers); //  [1, 2, 3, 4, 5, 4, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;foreach&#34;&gt;forEach()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;forEach()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组每一项都运行传入的函数，没有返回值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;undefined&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function(currentValue, index,arr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。函数，数组中的每个元素都会执行这个函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;thisValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。对象作为该执行回调时使用，传递给函数，用作 &amp;ldquo;this&amp;rdquo; 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;第一个参数（函数）的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。当前元素的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素属于的数组对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5,4,3,2,1];
let forEachResult = numbers.forEach((item,index,numbers) =&amp;gt; {
    return item*5
});
console.log(forEachResult); // undefined
console.log(numbers); // [1, 2, 3, 4, 5, 4, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;forEach()本质上就是循环遍历数组，没有返回值，也不会改变原数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这5个迭代方法传的参数都是一样的，也都不会改变原数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;6迭代器方法&#34;&gt;（6）迭代器方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在 &lt;strong&gt;ES6&lt;/strong&gt; 中，&lt;strong&gt;Array&lt;/strong&gt; 的原型上暴露了 &lt;strong&gt;3&lt;/strong&gt; 个用于检索数组内容的方法，&lt;strong&gt;keys()&lt;/strong&gt; 、&lt;strong&gt;values()&lt;/strong&gt; 和 &lt;strong&gt;entries()&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;keys&#34;&gt;keys()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;keys()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数组索引的迭代器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个类数组对象&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;obj&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。要返回其枚举自身属性的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;green&#39;];
console.log(colors.keys()); // Array Iterator {}
console.log(Array.from(colors.keys())); // [0, 1]
console.log(Array.of(...colors.keys())); // [0, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;values&#34;&gt;values()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;values()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数组元素的迭代器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个类数组对象&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;obj&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。被返回可枚举属性值的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;green&#39;];
console.log(colors.values()); // Array Iterator {}
console.log(Array.from(colors.values())); //  [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;]
console.log(Array.of(...colors.values())); //  [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;entries&#34;&gt;entries()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;entries()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回 索引/值 对的迭代器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个类数组对象&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;obj&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。被返回可枚举属性值的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let colors = [&#39;red&#39;,&#39;green&#39;];
console.log(colors.entries(colors)); // Array Iterator {}
console.log(Array.from(colors.entries())); // [Array(2), Array(2)]
console.log(Array.of(...colors.entries())); // [Array(2), Array(2)]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/000f722d46ac461faa31e0c5db37ca4d~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这三个方法返回的都是一个类数组对象，都可以通过 &lt;strong&gt;Array.from()&lt;/strong&gt; 或者 &lt;strong&gt;Array.of()加展开语法&lt;/strong&gt; 转换成数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;7归并方法&#34;&gt;（7）归并方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; 为数组提供了两个归并方法：&lt;strong&gt;reduce()&lt;/strong&gt; 和 &lt;strong&gt;reduceRight()&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;reduce&#34;&gt;reduce()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;reduce()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数组中的每个元素执行一个由您提供的reducer函数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;函数处理的结果，可以是任何类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function(currentValue, index,arr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。用于执行每个数组元素的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;initialValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。传递给函数的初始值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;第一个参数（函数）的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;total&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。初始值, 或者计算结束后的返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。当前元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentIndex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素所属的数组对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,2,1];
let sum = numbers.reduce((prev,cur,index,array) =&amp;gt; prev + cur);
console.log(sum); // 9
console.log(numbers); //  [1, 2, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;reduceright&#34;&gt;reduceRight()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;reduceRight()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从数组的末尾向前将数组中的数组项做累加&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;函数处理的结果，可以是任何类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function(currentValue, index,arr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。用于执行每个数组元素的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;initialValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。传递给函数的初始值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;第一个参数（函数）的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;total&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。初始值, 或者计算结束后的返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。当前元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentIndex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素所属的数组对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5];
let sum = numbers.reduceRight((prev,cur,index,array) =&amp;gt; prev + cur);
console.log(sum); // 15
console.log(numbers); // [1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;究竟是使用 &lt;strong&gt;reduce()&lt;/strong&gt; 还是 &lt;strong&gt;reduceRight()&lt;/strong&gt; ，只取决于遍历数组元素的方向。除此之外，这两个方法没什么区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;8搜索查找方法&#34;&gt;（8）搜索查找方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; 提供了 &lt;strong&gt;3&lt;/strong&gt; 个严格相等的搜索方法：&lt;strong&gt;indexOf()&lt;/strong&gt;、&lt;strong&gt;lastIndexOf()&lt;/strong&gt; 和 &lt;strong&gt;includes()&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;indexof&#34;&gt;indexOf()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;indexOf()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回在数组中可以找到一个给定元素的第一个索引&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数值类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;searchvalue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。规定需检索的字符串值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fromindex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选的整数参数。规定在字符串中开始检索的位置（包含这个位置）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5];
console.log(numbers.indexOf(4)); // 3
console.log(numbers.indexOf(4,3)); // 3
// 如果没找到就返回 -1
console.log(numbers.indexOf(40)); // -1
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;lastindexof&#34;&gt;lastIndexOf()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;lastIndexOf()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回查找元素在数组中的位置，从数组末尾开始向前查找&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数值类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;searchvalue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。规定需检索的字符串值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fromindex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选的整数参数。规定在字符串中开始检索的位置（包含这个位置）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5,4,3,2,1];
console.log(numbers.lastIndexOf(4)); // 5
console.log(numbers.lastIndexOf(4,4)); // 3
// 如果没找到就返回 -1
console.log(numbers.lastIndexOf(40)); // -1
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;includes&#34;&gt;includes()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;includes()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来判断一个数组是否包含一个指定的值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回布尔类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;searchvalue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需。规定需检索的字符串值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fromindex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选的整数参数。规定在字符串中开始检索的位置（包含这个位置）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5,4,3,2,1];
console.log(numbers.includes(4)); // true
console.log(numbers.includes(4,7)); // false
console.log(numbers.includes(40)); // false
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; 也允许按照定义的断言函数搜索数组，&lt;strong&gt;find()&lt;/strong&gt; 和 &lt;strong&gt;findIndex()&lt;/strong&gt; 使用了断言函数。&lt;/p&gt;
&lt;h3 id=&#34;find&#34;&gt;find()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;find()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数组中满足提供的测试函数的第一个元素的值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回符合条件的元素值，可以是任何类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function(currentValue, index,arr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。函数，数组中的每个元素都会执行这个函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;thisValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。对象作为该执行回调时使用，传递给函数，用作 &amp;ldquo;this&amp;rdquo; 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;第一个参数（函数）的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。当前元素的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素属于的数组对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;const people = [
    {
        name: &#39;Matt&#39;,
        age: 27
    },
    {
        name: &#39;xiaoming&#39;,
        age: 29
    }
];
console.log(people.find((element, index, array) =&amp;gt; element.age &amp;gt; 28)); // {name: &amp;quot;xiaoming&amp;quot;, age: 29}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;findindex&#34;&gt;findIndex()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;findIndex()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回数组中满足提供的测试函数的第一个元素的索引&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个数值类型的值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function(currentValue, index,arr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。函数，数组中的每个元素都会执行这个函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;thisValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。对象作为该执行回调时使用，传递给函数，用作 &amp;ldquo;this&amp;rdquo; 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;第一个参数（函数）的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。当前元素的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素属于的数组对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;const people = [
    {
        name: &#39;Matt&#39;,
        age: 27
    },
    {
        name: &#39;xiaoming&#39;,
        age: 29
    }
];
console.log(people.findIndex((element, index, array) =&amp;gt; element.age &amp;gt; 28)); // 1
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;9转换方法&#34;&gt;（9）转换方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; 中所有对象都有 &lt;strong&gt;toSting()&lt;/strong&gt;、&lt;strong&gt;toLocaleString()&lt;/strong&gt; 和 &lt;strong&gt;valueOf()&lt;/strong&gt; 方法，其中，&lt;strong&gt;valueOf()&lt;/strong&gt; 返回的是数组本身。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;tosting&#34;&gt;toSting()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;toSting()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回由数组中每个值的等效字符串拼接而成的一个用逗号分隔的字符串&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回字符串类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无需参数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无需描述&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [1,2,3,4,5];
let stringNumbers = numbers.toString();
console.log(stringNumbers); // 1,2,3,4,5
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;tolocalestring&#34;&gt;toLocaleString()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;toLocaleString()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个逗号分隔的数组值的字符串&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回字符串类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无需参数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无需描述&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let numbers = [15000000];
let stringNumbers = numbers.toLocaleString();
console.log(stringNumbers); // 15,000,000
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;10扁平化方法&#34;&gt;（10）扁平化方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; 中提供了两个数组扁平化的方法：&lt;strong&gt;flat()&lt;/strong&gt; 和 &lt;strong&gt;flatMap()&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;flat&#34;&gt;flat()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flat()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;会按照一个可指定的深度递归遍历数组，将所有元素与遍历到的子数组中的元素合并为一个新数组返回&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个数组类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;depth&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。指定要提取嵌套数组的结构深度，默认值为 1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let array = [1,5,9,8,[1],[2,[1,[1,3,[1,9]]]]];
console.log(array.flat(2));// [1, 5, 9, 8, 1, 2, 1, Array(3)]
//使用 Infinity，可展开任意深度的嵌套数组
console.log(array.flat(Infinity)); //  [1, 5, 9, 8, 1, 2, 1, 1, 3, 1, 9]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;flatmap&#34;&gt;flatMap()&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;返回值&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;是否改变原数组实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;flatMap()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;使用映射函数映射每个元素，然后将结果压缩成一个新数组&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回一个数组类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function(currentValue, index,arr)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。函数，数组中的每个元素都会执行这个函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;thisValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。对象作为该执行回调时使用，传递给函数，用作 &amp;ldquo;this&amp;rdquo; 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;第一个参数（函数）的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;currentValue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必须。当前元素的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素的索引值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;arr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选。当前元素属于的数组对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-Code&#34; data-lang=&#34;Code&#34;&gt;let array = [1,5,9,8];
let flatMapRes = array.flatMap((item,index,array) =&amp;gt; item * 3);
console.log(flatMapRes); // [3, 15, 27, 24]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;5总结&#34;&gt;5.总结&lt;/h1&gt;
&lt;p&gt;这篇文章断断续续的也写了好几天，感叹总结文档也是件麻烦细致活，不比学习技术知识花的时间少，但是写文档也算把学到的知识输出出来了，可能以后自己忘了，也能回头来看看，毕竟，人的记忆力是敌不过时间的，好记性不如烂笔头嘛，写文档这种东西可能还是多多益善，然后大佬们看这篇文章如果发现有不妥或者错误的地方希望能指出来，我及时改正，谢谢了，然后后续有新的东西我也会补充进来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60854fc6591d4c978418308db0d1ffe2~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
